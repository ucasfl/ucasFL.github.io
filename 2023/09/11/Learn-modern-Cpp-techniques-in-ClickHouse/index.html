<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Learn modern C++ techniques in ClickHouse | Blog Website</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="0. 前言从 C++11 开始的现代 C++ 是 C++ 编程语言的一次重大变革，在维持稳定性的情况下，从易用性、安全性、效率等各个方面增加了许多现代编程语言的特性。自 C++11 问世以来，受到了 C++ 开发者的广泛青睐，大量 C++ 项目都转向现代 C++ 或使用现代 C++ 进行开发，其中就包括 ClickHouse。 ClickHouse 是一款优秀的开源 OLAP 数据库，其出现可以算">
<meta property="og:type" content="article">
<meta property="og:title" content="Learn modern C++ techniques in ClickHouse">
<meta property="og:url" content="https://ucasfl.github.io/2023/09/11/Learn-modern-Cpp-techniques-in-ClickHouse/index.html">
<meta property="og:site_name" content="Blog Website">
<meta property="og:description" content="0. 前言从 C++11 开始的现代 C++ 是 C++ 编程语言的一次重大变革，在维持稳定性的情况下，从易用性、安全性、效率等各个方面增加了许多现代编程语言的特性。自 C++11 问世以来，受到了 C++ 开发者的广泛青睐，大量 C++ 项目都转向现代 C++ 或使用现代 C++ 进行开发，其中就包括 ClickHouse。 ClickHouse 是一款优秀的开源 OLAP 数据库，其出现可以算">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-09-11T13:42:53.000Z">
<meta property="article:modified_time" content="2023-10-07T09:35:22.000Z">
<meta property="article:author" content="flynn">
<meta property="article:tag" content="ClickHouse">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Blog Website" type="application/atom+xml">
  
  
    <link rel="icon" href="/photos/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  
<link rel="stylesheet" href="/css/styles.css">

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
          <li><a class=""
                 href="/about/">About</a></li>
        
          <li><a class=""
                 target="_blank" rel="noopener" href="https://github.com/ucasfl">GitHub</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">Blog Website</h1>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          <article id="post-Learn-modern-Cpp-techniques-in-ClickHouse" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 class="article-title" itemprop="name">
      Learn modern C++ techniques in ClickHouse
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2023/09/11/Learn-modern-Cpp-techniques-in-ClickHouse/" class="article-date"><time datetime="2023-09-11T13:42:53.000Z" itemprop="datePublished">2023-09-11</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C/">C++</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>从 C++11 开始的现代 C++ 是 C++ 编程语言的一次重大变革，在维持稳定性的情况下，从易用性、安全性、效率等各个方面增加了许多现代编程语言的特性。自 C++11 问世以来，受到了 C++ 开发者的广泛青睐，大量 C++ 项目都转向现代 C++ 或使用现代 C++ 进行开发，其中就包括 <a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse">ClickHouse</a>。</p>
<p>ClickHouse 是一款优秀的开源 OLAP 数据库，其出现可以算得上是划时代的产品，工程实现亦可以称为业内标杆，精巧的<a href="https://ucasfl.github.io/2022/09/21/How-Vectorization-Execution-Implemented-in-ClickHouse/">向量化引擎设计与实现</a>受到业内的广泛青睐和借鉴，引领了实时 OLAP 领域的一波浪潮。</p>
<p>本文会以 ClickHouse 代码为例，谈一谈其中使用到的一些常见现代 C++ 特性。然而，从 C++11 开始的现代 C++ 与之前版本的 C++ 相比，几乎可以算是一门新的语言，其包含太多新的语言特性和功能，因此本文不会详细罗列介绍现代 C++ 特性。</p>
<span id="more"></span>

<h1 id="1-从类型说起"><a href="#1-从类型说起" class="headerlink" title="1. 从类型说起"></a>1. 从类型说起</h1><p>C++ 是一个静态强类型语言，现代 C++ 的演进过程中显著增强和扩展了对类型处理的能力。</p>
<h2 id="1-1-值类别"><a href="#1-1-值类别" class="headerlink" title="1.1 值类别"></a>1.1 值类别</h2><p>为了解决中间结果带来的额外拷贝，C++11 引入了移动语义，同时对值类别重新进行了定义，值类别指的表达式结果的类别，与变量或类型的类别是两个不同的概念。过去通俗地说，如果一个变量或表达式能够取地址，则为左值；如果不能取地址，则为右值。</p>
<p>先看一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Field</span>(<span class="keyword">const</span> Field &amp; rhs);</span><br><span class="line">    <span class="built_in">Field</span>(Field &amp;&amp; rhs);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Field</code> 是 ClickHouse 类型系统中的一个重要数据结构，能够用于表示任意类型的单一值在内存中的存储，其既有参数为左值引用类型的拷贝构造函数，也有参数类型为右值引用的移动构造函数。下面的 <code>b</code> 和 <code>c</code> 对象会分别调用哪个构造函数呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Field &amp;&amp; a = 10;</span><br><span class="line">Field b(a);</span><br><span class="line">Field c(10);</span><br></pre></td></tr></table></figure>

<p>尽管 <code>a</code> 定义为了右值引用类型，但作为传入构造函数的表达式是一个左值（在介绍 <code>decltype</code> 时能够进一步理解），因此会调用第一个拷贝构造函数(也可以通过上面说的能否取地址来进行判断)，而显然后一个会调用移动构造函数。需要注意的是，左值引用只能绑定到左值表达式，常量左值引用既可以绑定到左值表达式，也可以绑定到右值表达式，但对于右值引用，无论是常量还是非常量，均只能绑定到右值表达式。</p>
<p>为了使 <code>a</code> 绑定到移动构造函数，可以通过 <code>Field d(static_cast&lt;int&amp;&amp;&gt;(a))</code> 实现，而这正是移动语义 <code>std::move</code> 所做的工作，其会强制将一个表达式转换为右值引用类型。<code>std::move(a)</code> 在 C++11 中被称为将亡值，将亡值和纯右值统称为右值。</p>
<h2 id="1-2-移动语义"><a href="#1-2-移动语义" class="headerlink" title="1.2 移动语义"></a>1.2 移动语义</h2><p>引入右值引用之后，即可以很方便地表达移动语义。拷贝语义与移动语义都是将原值赋予目的值，但拷贝语义不会修改原值的内容，而移动语义可能会。引用移动语义之后，移动构造变得更加简单，当传入的参数为临时值或者是 <code>std::move</code> 后的对象，则自动触发移动构造。</p>
<p>在 ClickHouse 中，移动语义非常普遍，并且在某些场景下，需要禁止拷贝语义，只支持移动语义。在 ClickHouse 中，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/6211845ef0f1416dc68414923fbc9da782245949/src/Columns/IColumn.h#L44-L605">Column</a> 是数据在内存中的列存表示，是 ClickHouse 向量化执行的基础；例如，<code>ColumnVector</code> 用于存储数值类型的列，<code>ColumnString</code> 用于存储字符串类型的列，<code>ColumnMap</code> 用于存储 Map 类型的列等。<code>IColumn</code> 接口类继承自 <a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/6211845ef0f1416dc68414923fbc9da782245949/src/Common/COW.h#L8-L76"><code>COW</code></a> 以实现 Column 对象的 Copy-On-Write。</p>
<p>在 <code>COW</code> 中，分别实现了 <code>mutable_ptr</code> 和 <code>immutable_ptr</code>，前者可以指向一个 mutable 的对象，后者可以指向 immutable 的对象，其中，<code>mutable_ptr</code> 是不可以共享的，而 <code>imutable_ptr</code> 是可以共享的，如果想共享一个 <code>mutable_ptr</code> 指针指向的对象，则需要将 <code>mutable_ptr</code> 移动赋值给 <code>immutable_ptr</code>。这两个指针的实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mutable_ptr</span> :</span> <span class="keyword">public</span> boost::intrusive_ptr&lt;T&gt; <span class="comment">/// NOLINT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// Copy: not possible.</span></span><br><span class="line">    <span class="built_in">mutable_ptr</span>(<span class="keyword">const</span> mutable_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Move: ok.</span></span><br><span class="line">    <span class="built_in">mutable_ptr</span>(mutable_ptr &amp;&amp;) = <span class="keyword">default</span>; <span class="comment">/// NOLINT</span></span><br><span class="line">    mutable_ptr &amp; <span class="keyword">operator</span>=(mutable_ptr &amp;&amp;) = <span class="keyword">default</span>; <span class="comment">/// NOLINT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initializing from temporary of compatible type.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">mutable_ptr</span>(mutable_ptr&lt;U&gt; &amp;&amp; other) : <span class="built_in">Base</span>(std::<span class="built_in">move</span>(other)) &#123;&#125; <span class="comment">/// NOLINT</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">immutable_ptr</span> :</span> <span class="keyword">public</span> boost::intrusive_ptr&lt;<span class="keyword">const</span> T&gt; <span class="comment">/// NOLINT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// Copy from immutable ptr: ok.</span></span><br><span class="line">    <span class="built_in">immutable_ptr</span>(<span class="keyword">const</span> immutable_ptr &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    immutable_ptr &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> immutable_ptr &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">immutable_ptr</span>(<span class="keyword">const</span> immutable_ptr&lt;U&gt; &amp; other) : <span class="built_in">Base</span>(other) &#123;&#125; <span class="comment">/// NOLINT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Move: ok.</span></span><br><span class="line">    <span class="built_in">immutable_ptr</span>(immutable_ptr &amp;&amp;) = <span class="keyword">default</span>; <span class="comment">/// NOLINT</span></span><br><span class="line">    immutable_ptr &amp; <span class="keyword">operator</span>=(immutable_ptr &amp;&amp;) = <span class="keyword">default</span>; <span class="comment">/// NOLINT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Initializing from temporary of compatible type.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">immutable_ptr</span>(immutable_ptr&lt;U&gt; &amp;&amp; other) : <span class="built_in">Base</span>(std::<span class="built_in">move</span>(other)) &#123;&#125; <span class="comment">/// NOLINT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Move from mutable ptr: ok.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">immutable_ptr</span>(mutable_ptr&lt;U&gt; &amp;&amp; other) : <span class="built_in">Base</span>(std::<span class="built_in">move</span>(other)) &#123;&#125; <span class="comment">/// NOLINT</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Copy from mutable ptr: not possible.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="built_in">immutable_ptr</span>(<span class="keyword">const</span> mutable_ptr&lt;U&gt; &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>mutable_ptr</code> 中，不能支持共享，因为如果两个 <code>mutable_ptr</code> 指向同一个对象，那么在修改对象时，则不是线程安全的，为了避免这种情况发生，则需要禁止拷贝语义，只支持移动语义，从而保证了不会有两个不同的 <code>mutable_ptr</code> 指向同一个对象。而在 <code>immutable_ptr</code> 中，拷贝和移动都是支持的，从而支持只读共享，同时，也可以将一个 <code>mutable_ptr</code> 移动赋值给 <code>immutable_ptr</code> 以支持共享，但不能是拷贝语义，否则同样会影响线程安全。</p>
<p>那么，Copy-On-Write 是怎么实现的呢？当需要修改一个 <code>immutable_ptr</code> 指针指向的对象时，则可以通过 <code>COW</code> 类提供的 <code>clone</code> 或 <code>mutate</code> 方法拷贝一个新的对象，然后再进行修改。</p>
<p>此外，针对移动语义，需要注意的是，对于从函数返回的局部变量，切勿通过 <code>return std::move(tmp_variable)</code> 来尝试将“复制”转为“移动”，而忽略了 C++ 一直存在的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Copy_elisionn">返回值优化（RVO）</a>：当需要从函数返回的局部对象类型与函数返回值类型相同，并且返回的是局部对象本身时，能够省略局部对象的复制或移动，即使编译器未执行复制省略，也需要将返回对象作为右值处理。因此，如果添加了 <code>std::move</code>，反而可能会使得 RVO 无法实施，带来不必要的临时对象构造、析构开销。</p>
<h2 id="1-3-转发引用"><a href="#1-3-转发引用" class="headerlink" title="1.3 转发引用"></a>1.3 转发引用</h2><p>转发引用（forwarding reference，也称为万能引用）的引入是为了解决模板函数重载带来的代码膨胀问题和可扩展性问题，如果没有转发引用，那么许多情况下我们需要针对左值引用和右值引用分别实现不同的函数。</p>
<p>例如，现在我们有一个继承自 <code>std::string</code> 的类 <code>A</code>，为了能够使得在传入右值的时候进行 <code>std::string</code> 的移动构造，传入 左值的时候进行拷贝构造，那么其可能需要有如下不同形参的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> std::string</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(std::string &amp;&amp; s): std::<span class="built_in">string</span>(std::<span class="built_in">move</span>(s)) &#123;&#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">const</span> std::string &amp; s): std::<span class="built_in">string</span>(s) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这儿，如果使用转发引用作为形参，那么只需要实现如下一个构造函数即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> std::string</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="title">A</span><span class="params">(T &amp;&amp; s)</span>: std::string(std::forward&lt;T&gt;(s)) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>转发引用形如前面提到的右值引用，但其既可以绑定到右值，也可以绑定到左值，能够绑定到 <code>const</code> 对象，也能绑定到非 <code>const</code> 对象。而在使用转发引用时，则必然离不开“转发”：<code>std::forward</code>，其能够使目标函数与转发函数接收到相同的实参，即在参数传递过程中保持值类别的不变，左值依旧为左值，右值依旧为右值。</p>
<p>由于函数形参均表现为左值语义，因此 <code>std::forward</code> 会在 <code>A</code> 的构造函数传入实参为右值的情况下，将其强制转换为右值，从而使得能够调用 <code>std::string</code> 的移动构造函数。如果要更进一步理解转发引用的工作原理，则需要了解 C++11 的<a target="_blank" rel="noopener" href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">引用折叠（reference collapsing）</a>机制，本文不再进行阐述。当然，在上述例子中，为了对模板类型进行约束，可以通过 <code>concept</code> 来实现，之后的构造函数变为如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> std::string</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">requires</span> std::convertible_to&lt;T, std::string&gt;</span></span><br><span class="line"><span class="function">    <span class="title">A</span><span class="params">(T &amp;&amp; s)</span>: std::string(std::forward&lt;T&gt;(s)) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这儿用到了 <code>std::convertiable_to</code> 这一 <code>concept</code>，表示类型 <code>T</code> 需要能够隐式转换为 <code>std::string</code>，否则模板会替换失败，在下文中会进一步对 <code>concept</code> 进行介绍。</p>
<p>可以看到，使用转发引用形参，能够减少不必要的代码编写。特别是，当形参越多时，如果采用重载的方式，由于每一个形参都有左值和右值，那么重载函数的数量将会成指数增长。在 C++11 引入变参模板之后，函数可能有无穷多个形参，在这种情况下，只能使用转发引用作为形参，例如 <code>std::make_shared</code> 和 <code>std::make_unique</code> 的实现，其声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">shared_ptr&lt;T&gt; make_shared&lt;Args &amp;&amp;... args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">unique_ptr&lt;T&gt; make_unique&lt;Args &amp;&amp;... args);</span><br></pre></td></tr></table></figure>

<p><strong>如何区分右值引用和转发引用？</strong> </p>
<ul>
<li>如果 <code>T &amp;&amp;</code> 中的 <code>T</code> 涉及类型推导，则为转发引用。</li>
</ul>
<p>例如出现在函数模板中，此时 <code>param</code> 为转发引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span> <span class="params">(T &amp;&amp; param)</span></span>;  </span><br></pre></td></tr></table></figure>

<p>例如，<code>auto</code> 声明中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;&amp; var2 = var1; <span class="comment">// var2 为转发引用</span></span><br></pre></td></tr></table></figure>
<p>或者出现在函数参数类型推导中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">auto</span> &amp;&amp; param)</span> </span>&#123;...&#125; <span class="comment">// param 为转发引用，从 C++20 开始支持</span></span><br></pre></td></tr></table></figure>
<p>上述声明等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;&amp; param)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>反之，如果 <code>T &amp;&amp;</code> 中的 <code>T</code> 为具体类型，则为右值引用，例如:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
需要注意的是，在下面这一个例子中，<code>param</code> 是右值引用，而不是转发引用，这是因为在这儿 <code>f</code> 并不涉及型别推导，实例 <code>A</code> 的具体型别确定了 <code>f</code> 的型别，而在 <code>g</code> 中，<code>Args</code> 独立于 <code>T</code>，因此 <code>args</code> 为转发引用。在标准库中类似的例子可参考 <code>std::vector</code> 的 <code>push_back</code> 和 <code>emplace_back</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;&amp; param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">g</span><span class="params">(Args... &amp;&amp; args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>网上一些文章在介绍左值、右值的过程中，<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/161039484">错误混淆了右值引用和转发引用</a>，例如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;左值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;右值&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testFoward</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，尽管当传入参数为左值时，根据模板的重载决议，会调用第一个左值引用版本的 <code>print</code> 函数，但第二个 <code>print</code> 函数中的形参并非为右值引用，而是转发引用，因此实际上左值引用版本的实现完全是多余的。</p>
<p>转发引用在 ClickHouse 中的随处可见，例如前面提到的 <code>Field</code> 类的构造函数之一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                                                                                   </span><br><span class="line">    <span class="built_in">Field</span>(T &amp;&amp; rhs, <span class="keyword">enable_if_not_field_or_bool_or_stringlike_t</span>&lt;T&gt; = <span class="literal">nullptr</span>);   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 <a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/5d063e5960f8b95b71b5a01939467c76e8e19cd7/src/Storages/MergeTree/KeyCondition.h#L27-L40"><code>FieldRef</code> 继承自 <code>Field</code></a>，其中一个构造函数如下，通过 <code>std::forward</code> 保证传递过程中参数值语义的不变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FieldRef</span> :</span> <span class="keyword">public</span> Field</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// Create as explicit field without block.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="built_in">FieldRef</span>(T &amp;&amp; value) : <span class="built_in">Field</span>(std::forward&lt;T&gt;(value)) &#123;&#125; <span class="comment">/// NOLINT</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/5d063e5960f8b95b71b5a01939467c76e8e19cd7/src/Storages/MergeTree/ZooKeeperRetries.h#L36-L101">类成员函数的形参</a>，在这儿，三个成员函数的形参均为转发引用，而不是右值引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperRetriesControl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retryLoop</span><span class="params">(<span class="keyword">auto</span> &amp;&amp; f)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">retryLoop</span><span class="params">(<span class="keyword">auto</span> &amp;&amp; f, <span class="keyword">auto</span> &amp;&amp; iteration_cleanup)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">callAndCatchAll</span><span class="params">(<span class="keyword">auto</span> &amp;&amp; f)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-自动类型推导"><a href="#1-4-自动类型推导" class="headerlink" title="1.4 自动类型推导"></a>1.4 自动类型推导</h2><h3 id="1-4-1-auto-类型推导"><a href="#1-4-1-auto-类型推导" class="headerlink" title="1.4.1 auto 类型推导"></a>1.4.1 <code>auto</code> 类型推导</h3><p><code>auto</code> 类型推导、基于范围的 <code>for</code> 循环和 lambda 表达式<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3386320">据称是 C++11 中最受用户欢迎的三个特性</a> 。</p>
<p>有了 <code>auto</code> 类型推导，很多情况下不需要再写出繁琐的类型名称，<code>auto</code> 类型推导的规则与模板类型推导规则基本相同（除大括号初始化的情况外）。需要注意的是，<code>auto</code> 表现为值语义，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> b = a;</span><br></pre></td></tr></table></figure>
<p>此时，<code>b</code> 的类型为 <code>int</code>，丢失了引用语义和 <code>cv</code> 属性，如果需要保留引用语义，则需要声明为 <code>auto &amp; b = a</code>，此时 <code>b</code> 的类型为 <code>const int &amp;</code>。这与模板的类型推导是完全一致的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T &amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(a); <span class="comment">// 此时 T 和 param 的类型均为 int</span></span><br><span class="line"><span class="built_in">g</span>(a); <span class="comment">// 此时 T 的类型为 const int, param 的类型为 const int &amp;</span></span><br></pre></td></tr></table></figure>

<p>而在转发引用的场景下，类型推导规则同样与模板推导规则一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> const_n =  n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; const_ref = n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; x1 = n; <span class="comment">// x1 的类型为 int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; x2 = const_n; <span class="comment">// x2 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; x3 = const_ref; <span class="comment">// x3 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp; x4 = <span class="number">10</span>; <span class="comment">// x4 的类型为 int &amp;&amp;</span></span><br></pre></td></tr></table></figure>

<p>C++11 支持了函数返回值类型的尾序指定语法，如下所示，<code>decltype</code> 能够获取到参数表达式的具体类型，在下文中会进行介绍，通过这一方式，能够实现返回值类型的自动推导。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">(T &amp;&amp; a)</span> -&gt; <span class="title">decltype</span><span class="params">(std::forward&lt;T&gt;(a))</span> </span>&#123; <span class="keyword">return</span> std::forward&lt;T&gt;(a);&#125;</span><br></pre></td></tr></table></figure>

<p>C++14 进一步增强了返回值类型推导的功能，上述函数可直接写为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">f</span><span class="params">(T &amp;&amp; a)</span> </span>&#123; <span class="keyword">return</span> std::forward&lt;T&gt;(a); &#125;</span><br></pre></td></tr></table></figure>
<p>同时，C++14 也支持了 lambda 表达式参数的 <code>auto</code> 推导，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">auto</span> param) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>
<p>但普通函数的参数自动推导则直到 C++20 才支持，从而完成了 lambda 表达式参数和普通函数参数 <code>auto</code> 类型推导的统一。在 C++ 20 中，我们可以写出类似下面这样的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">g</span><span class="params">(<span class="keyword">auto</span> &amp;&amp; a)</span> </span>&#123; <span class="keyword">return</span> std::forward&lt;<span class="keyword">decltype</span>(a)&gt;(a);&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，其等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T &amp;&amp; <span class="title">g</span><span class="params">(T &amp;&amp; a)</span> </span>&#123; <span class="keyword">return</span> std::forward&lt;T&gt;(a); &#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子只是为了介绍功能，并无实际意义。事实上，<code>auto</code> 的使用并不是越多越好，过度使用会对代码的可读性造成极大的影响。在使用 <code>auto</code> 类型推导时，我们可尽可能手动指定 <code>cv</code> 属性或通过 <code>*</code> 表明指针类别，即使类型推导能够推导出来，从而能够提高代码的可读性。</p>
<p>例如，在下面的例子中，函数返回值类型是 <code>const</code> 引用，那么在调用时仅使用 <code>auto &amp;</code> 也能够推导出正确的类型，但是与 <code>const auto &amp;</code> 相比，显然代码可读性更差，如果不去看函数的实现，那么就没法得知该返回值为常量引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Settings &amp; <span class="title">getSettingsRef</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> settings; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// auto &amp; settings = context-&gt;getSettingsRef(); 此时 settings 的类型仍然为 const Settings &amp;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; settings = context-&gt;<span class="built_in">getSettingsRef</span>();</span><br></pre></td></tr></table></figure>

<p>而对于指针的情况同样如此：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> * array_type = typeid_cast&lt;<span class="keyword">const</span> DataTypeArray *&gt;(type_ptr.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
<p>会比</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> array_type = typeid_cast&lt;<span class="keyword">const</span> DataTypeArray *&gt;(type_ptr.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
<p>具有更好的代码可读性，尽管二者是等价的。</p>
<h3 id="1-4-2-decltype、declval-与-decay-t"><a href="#1-4-2-decltype、declval-与-decay-t" class="headerlink" title="1.4.2 decltype、declval 与 decay_t"></a>1.4.2 <code>decltype</code>、<code>declval</code> 与 <code>decay_t</code></h3><p>从 C++11 起，引入了 <code>decltype</code> 用于获取表达式的类型，从而打破了从值获得类型的枷锁，在元编程中，<code>decltype</code> 具有重要的应用。</p>
<p>需要注意的是，<code>decltype</code> 有两个版本：不带括号的版本和带括号的版本。不带括号的版本用于获取标志符的类型，即标志符定义时的类型，是最符合我们常规认识的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * cp = &amp;n;</span><br><span class="line"><span class="keyword">int</span> &amp; lrn = n;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rfn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> T1 = <span class="keyword">decltype</span>(n); <span class="comment">// int</span></span><br><span class="line"><span class="keyword">using</span> T2 = <span class="keyword">decltype</span>(p); <span class="comment">// int *</span></span><br><span class="line"><span class="keyword">using</span> T3 = <span class="keyword">decltype</span>(cp); <span class="comment">// const int *</span></span><br><span class="line"><span class="keyword">using</span> T4 = <span class="keyword">decltype</span>(lrn); <span class="comment">// int &amp;</span></span><br><span class="line"><span class="keyword">using</span> T5 = <span class="keyword">decltype</span>(rfn); <span class="comment">// int &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>而带括号的版本返回的是表达式的值类别，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * cp = &amp;n;</span><br><span class="line"><span class="keyword">int</span> &amp; lrn = n;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp; rfn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左值（带一个引用）</span></span><br><span class="line"><span class="keyword">using</span> T1 = <span class="keyword">decltype</span>((n)); <span class="comment">// int &amp;</span></span><br><span class="line"><span class="keyword">using</span> T2 = <span class="keyword">decltype</span>((p)); <span class="comment">// int * &amp;</span></span><br><span class="line"><span class="keyword">using</span> T3 = <span class="keyword">decltype</span>((cp)); <span class="comment">// const int * &amp;</span></span><br><span class="line"><span class="keyword">using</span> T4 = <span class="keyword">decltype</span>((lrn)); <span class="comment">// int &amp;</span></span><br><span class="line"><span class="keyword">using</span> T5 = <span class="keyword">decltype</span>((rfn)); <span class="comment">// int &amp;</span></span><br><span class="line"><span class="keyword">using</span> T6 = <span class="keyword">decltype</span>((++n); <span class="comment">// int &amp;</span></span><br><span class="line"><span class="comment">// 纯右值（不带引用）</span></span><br><span class="line"><span class="keyword">using</span> T7 = <span class="keyword">decltype</span>((n++)); <span class="comment">// int</span></span><br><span class="line"><span class="keyword">using</span> T8 = <span class="keyword">decltype</span>((<span class="number">10</span>)); <span class="comment">// int</span></span><br><span class="line"><span class="comment">// 将亡值（带两个引用）</span></span><br><span class="line"><span class="keyword">using</span> T9 = <span class="keyword">decltype</span>((std::<span class="built_in">move</span>(n)); <span class="comment">// int &amp;&amp;</span></span><br><span class="line"><span class="keyword">using</span> T10 = <span class="keyword">decltype</span>((<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> &amp;&amp;&gt;(n))); <span class="comment">// int &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，对于 <code>T5</code>，尽管 <code>rfn</code> 定义为了右值引用类型，但其作为表达式整体则表现为左值，同时，<code>++n</code> 作为表达式来说其结果为左值，而 <code>n++</code> 作为表达式其结果为右值。</p>
<p>此外，C++14 引入了 <code>decltype(auto)</code> 的类型推导方式。这是因为 <code>auto</code> 本身表现为值语义，丢失了引用性和 const 属性，若主动指明 const 或引用，则又导致结果始终为 const 或只能表现为引用语义，因此不够通用，特别是在范型编程场景下用。而 <code>decltype</code> 既能获取标志符定义时的完整类型，也能获取整体作为表达式时候的值类别，因此总是能够准确获取到等号右边表达式的类型。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) n1 = n; <span class="comment">// n1 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) n2 = (n); <span class="comment">// n2 的类型为 int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) n3 = <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// n3 的类型为 int</span></span><br></pre></td></tr></table></figure>
<p>在这儿，<code>auto</code> 的作用主要是作为占位符，类型推导按照 <code>decltype</code> 的规则来，比较常见的用法是用于函数的返回值类型推导，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Container&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">elemAt</span><span class="params">(Container &amp;&amp; c, <span class="keyword">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::forward&lt;Container&gt;(c)[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这儿，结合转发引用，只要类型 <code>Container</code> 具有 operator <code>[]</code>，无论是左值右值，是否为 const，总能正常执行并将结果以正确的类型返回。</p>
<p>通过 <code>decltype</code>，我们可以在非求值上下文中某个类的某个函数的返回值类型，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> ReturnType = <span class="keyword">decltype</span>(F&#123;&#125;.<span class="built_in">func</span>(Args&#123;&#125;...));</span><br></pre></td></tr></table></figure>
<p>在这儿，由于无法对类型直接调用，因此需要对 <code>F</code> 和 <code>Args</code> 均进行实例化，得到一个合法的函数调用语句，并通过 <code>decltype</code> 获取返回值类型，这儿的实例化并不会在真正在内存中构造出对象，仅在编译期非求值上下文中，用于构造合法的语句。当 <code>F</code> 和 <code>Args</code> 都有默认构造函数时，一切都正常，然而，如果没有，或者构造函数不可用，那么上述方法便不可行，因为 <code>F&#123;&#125;</code> 和 <code>Args&#123;&#125;</code> 是无效的。</p>
<p>为了解决上述问题，需要引入 C++11 标准库中的 <code>std::declval</code> 模板函数，其能够不受上述约束而构造出对象，只需要将 <code>F&#123;&#125;</code> 改成 <code>std::declval&lt;F&gt;()</code> 即可，因此上述实现需改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">using</span> ReturnType = <span class="keyword">decltype</span>(std::declval&lt;F&gt;().<span class="built_in">func</span>(std::declval&lt;Args&gt;()...));</span><br></pre></td></tr></table></figure>
<p>事实上，C++标准库中 <code>std::declval</code> 会返回一个模板参数的转发引用，并且只能用于诸如 <code>decltype</code> 和 <code>sizeof</code> 之类的非求值上下文中，其只有一个函数声明，而没有定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">declval</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是因为，在非求值上下文中，我们并不需要真正构造对象，因此只需要返回一个引用即可，同时返回转发引用保留了左值和右值引用的属性。另外，由于没有函数定义，能够防止被用于求值环境中，因为一旦使用，就会在编译时出现模板函数未定义的链接错误。</p>
<p>例如，下面是 ClickHouse 中<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/39e481934c8cf99fe698c9b5d109d8b9ab2464c6/src/Interpreters/Aggregator.cpp#L326-L330">一个 concept 的定义</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HashTable, <span class="keyword">typename</span> KeyHolder&gt;</span><br><span class="line"><span class="keyword">concept</span> HasPrefetchMemberFunc = <span class="keyword">requires</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;std::declval&lt;HashTable&gt;().<span class="built_in">prefetch</span>(std::declval&lt;KeyHolder&gt;())&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该 concept 表示类型 <code>HashTable</code> 需要具有一个以 <code>KeyHolder</code> 为参数的方法 <code>prefetch</code>，由于并不知道 <code>HashTable</code> 和 <code>KeyHolder</code> 是否具有默认构造函数，因此这儿需要通过 <code>std::declval</code> 来构造对象，实现编译期的求值。</p>
<p>最后，介绍一个用于类型退化的模板类 <code>std::decay</code>，其具有一个成员类型 <code>type</code>，从 C++14 起，<code>std::decay_t&lt;T&gt;</code> 就等价于 <code>std::decay&lt;T&gt;::type</code>。考虑如下一个场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_V&lt;T, <span class="keyword">int</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do otherthing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::is_same_v</code> 是从 C++11（准确说是 C++17）开始引入的判断两个类型是否相同的模板变量，<code>if constexpr</code> 会在编译时对表达式进行评估，生成对应分支的代码，这个函数的意思是，希望当 <code>T</code> 的类型为 <code>int</code> 和不为 <code>int</code> 时，分别生成不同逻辑的代码。然而，在这儿，由于 <code>param</code> 是一个转发引用，其总是一个引用，并且还可能有 const 修饰符，因此，上述逻辑无法实现这一功能，这时候就需要引入 <code>std::decay_t</code>，因为 <code>std::decay_t&lt;T&gt;</code> 得到的类型是 <code>T</code> 除去 const 修饰符、除去引用后的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T1 = std::<span class="keyword">decay_t</span>&lt;<span class="keyword">int</span>&gt;; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">using</span> T2 = std::<span class="keyword">decay_t</span>&lt;<span class="keyword">int</span>&amp;&gt;; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">using</span> T3 = std::<span class="keyword">decay_t</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp;&gt;; <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>因此，上述模板函数的正确实现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_V&lt;std::<span class="keyword">decay_t</span>&lt;T&gt;, <span class="keyword">int</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do otherthing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，对于数组，得到的是数组元素的指针类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T4 = std::<span class="keyword">decay_t</span>&lt;<span class="keyword">int</span>[<span class="number">4</span>]&gt;; <span class="comment">// int *</span></span><br></pre></td></tr></table></figure>
<p>而对于函数，得到的是函数指针类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T5 = std::<span class="keyword">decay_t</span>&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt;; <span class="comment">// int(*)(int)</span></span><br></pre></td></tr></table></figure>

<p>在 ClickHouse 的 UDF 实现中，<code>decltype</code> 与 <code>decay_t</code> 结合被大量使用，用于从值推导类型。下面的例子是<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/pull/6999">函数 <code>repeat</code></a> 的执行逻辑代码片段，该函数接收一个 <code>String</code> 列和一个整数列，返回字符串重复整数次后的字符串。该 <code>if</code> 条件处理传入的整数列是一个常量的情况，但由于整型常量可能是不同的类型，<code>UInt8</code>、<code>UInt32</code> 等都有可能，因此需要先得到具体的类型，再从 Column 中获取值。函数的参数里面有 <code>DataType</code> 参数 <code>type</code>，需要得到 <code>type</code> 的类型，然后其 <code>FieldType</code> 就是 Column 中存储的数据的类型。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> ColumnConst * col_num_const = checkAndGetColumn&lt;ColumnConst&gt;(col_num.<span class="built_in">get</span>()))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> col_res = ColumnString::<span class="built_in">create</span>();</span><br><span class="line">    <span class="built_in">castType</span>(arguments[<span class="number">1</span>].type.<span class="built_in">get</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> DataType = std::<span class="keyword">decay_t</span>&lt;<span class="keyword">decltype</span>(type)&gt;;</span><br><span class="line">        <span class="keyword">using</span> T = <span class="keyword">typename</span> DataType::FieldType;</span><br><span class="line">        T times = col_num_const-&gt;getValue&lt;T&gt;();</span><br><span class="line">        RepeatImpl::<span class="built_in">vectorStrConstRepeat</span>(col-&gt;<span class="built_in">getChars</span>(), col-&gt;<span class="built_in">getOffsets</span>(), col_res-&gt;<span class="built_in">getChars</span>(), col_res-&gt;<span class="built_in">getOffsets</span>(), times);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> col_res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>decltype(type)</code> 返回的是一个完整的类型，可能包含引用等，再加上 <code>decay_t</code> 得到退化后的类型，最终实现从值到类型的推导。</p>
<h3 id="1-4-3-CTAD"><a href="#1-4-3-CTAD" class="headerlink" title="1.4.3 CTAD"></a>1.4.3 CTAD</h3><p>C++17 进一步支持了类模板参数推导，当实例化一个模板类时，编译器能够根据参数自动推导模板类型，一个最直接的例子是 <code>std::pair</code> 的声明更方便了，也不再需要使用 <code>std::make_pair</code> 了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// C++17 之前</span></span><br><span class="line"><span class="function">std::pair <span class="title">p2</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>; <span class="comment">// C++17</span></span><br></pre></td></tr></table></figure>

<p>CTAD 能够使得代码更加简洁统一，例如，过去在使用同步原语时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">...</span><br><span class="line">std::shared_mutex shared_mutex;</span><br><span class="line"><span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">shared_lock</span><span class="params">(shared_mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而现在，只需要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex;</span><br><span class="line"><span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">...</span><br><span class="line">std::shared_mutex shared_mutex;</span><br><span class="line"><span class="function">std::shared_lock <span class="title">shared_lock</span><span class="params">(shared_mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="2-资源管理"><a href="#2-资源管理" class="headerlink" title="2. 资源管理"></a>2. 资源管理</h1><p>不同于自动回收垃圾的托管语言，C++ 需要用户手动管理对象生命周期，以防止内存泄漏。</p>
<h2 id="2-1-RAII"><a href="#2-1-RAII" class="headerlink" title="2.1 RAII"></a>2.1 RAII</h2><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/raii">RAII</a> 来自 C++98，并不是现代 C++ 才提出的内容，但其是 C++ 资源管理的核心，全称是：Resource Acquisition Is Initialization, 资源获取即初始化。RAII 的本质思想是每个资源都应该有一个所有者，由作用域对象表示：在构造函数中获取资源，在析构函数中释放资源。RAII 几乎遍布所有的 C++ 库，资源不仅仅指的是内存，也包括文件句柄、socket 连接、锁等。</p>
<p>RAII 可以总结为：</p>
<ul>
<li>将每一个资源都封装到类中：在构造函数中获取资源并建立<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Class_invariant">类不变量</a>，如果不能完成则抛出异常；在析构函数中释放所有资源并且<strong>不能抛出异常（析构函数抛出异常会导致资源泄漏）</strong>；</li>
<li>始终通过 RAII-类的实例来使用资源：该对象具有自动存储周期或临时生命周期（栈上分配的对象），或者生命周期与一个具有自动存储周期或临时生命周期的对象绑定（在堆上分配的栈上对象的成员，由栈上对象的构造析构负责分配释放）。</li>
</ul>
<p>例如，现代 C++ 中的互斥锁包装器 <code>std::lock_guard</code> 就是一个典型的 RAII 类，其能够在作用域生命周期内持有一个互斥锁：在创建对象时获取锁，在析构时释放锁。在这儿，资源就是互斥锁。<br>在 ClickHouse 这样的数据库系统中，在许多地方都涉及到资源的互斥访问，因此大量使用了互斥锁，使用过程中通常都要结合 <code>std::lock_guard</code>，使用方式基本都是如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassName::funcName</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// 获取 mutex(对象中的成员)</span></span><br><span class="line">    <span class="comment">/// 访问互斥资源</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/// 当离开作用域时，std::lock_guard 析构，隐式释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/17127cf23f9f32431de2b928a8877f902c99ec3c/src/Storages/Cache/RemoteCacheController.h#L55C30-L80">通过互斥锁实现多线程对对象状态的互斥访问和修改</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">markInvalid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    valid = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isValid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isEnable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> is_enable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">disable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    is_enable = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    is_enable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，在 RAII 中，还值得一提的是类成员的构造顺序和析构顺序：类成员总是按照定义的顺序来构造的，而不是按照初始化列表的顺序，而析构的顺序则反过来。某些情况下，当两个类有循环依赖时，需要注意类成员定义的顺序，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/17127cf23f9f32431de2b928a8877f902c99ec3c/src/Storages/FileLog/FileLogDirectoryWatcher.h#L59-L74">否则可能导致析构时的数据竞争</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileLogDirectoryWatcher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">FileLogDirectoryWatcher</span>(<span class="keyword">const</span> std::string &amp; path_, StorageFileLog &amp; storage_, ContextPtr context_);</span><br><span class="line">    ~<span class="built_in">FileLogDirectoryWatcher</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectoryWatcherBase</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/// Note, in order to avoid data race found by fuzzer, put events before dw,</span></span><br><span class="line">    <span class="comment">/// such that when this class destruction, dw will be destructed before events.</span></span><br><span class="line">    <span class="comment">/// The data race is because dw create a separate thread to monitor file events</span></span><br><span class="line">    <span class="comment">/// and put into events, then if we destruct events first, the monitor thread still</span></span><br><span class="line">    <span class="comment">/// running, it may access events during events destruction, leads to data race.</span></span><br><span class="line">    <span class="comment">/// And we should put other members before dw as well, because all of them can be</span></span><br><span class="line">    <span class="comment">/// accessed in thread created by dw.</span></span><br><span class="line">    Events events;</span><br><span class="line">    ...</span><br><span class="line">    std::unique_ptr&lt;DirectoryWatcherBase&gt; dw;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类 <code>FileLogDirectoryWatcher</code> 中，其成员 <code>dw</code> 中有一个线程会持续访问 <code>events</code> 成员，直到析构 <code>dw</code> 时停止运行。因此，在该类的定义中，我们必须先声明 <code>events</code>，再声明 <code>dw</code>，保证析构时能够先析构 <code>dw</code>，再析构 <code>events</code>，若顺序反过来，那么将会出现数据竞争：析构线程想要析构 <code>events</code> 对象，而 <code>dw</code> 中的线程还在访问 <code>events</code> 对象。</p>
<p>RAII 并不能够完全解决垃圾回收的需求，而 C++11 引入了资源管理指针，二者结合，消除了垃圾回收的需求。</p>
<h2 id="2-2-智能指针"><a href="#2-2-智能指针" class="headerlink" title="2.2 智能指针"></a>2.2 智能指针</h2><p>C++11 引入了智能指针 <code>shared_ptr</code> 和 <code>unique_ptr</code>，分别用于共享所有权和独占所有权。<code>shared_ptr</code> 通过引用计数实现资源的共享：指向同一对象所有指针共享一个计数器，当最后一个指向对象的指针被销毁（计数器变为 0）之后，对象也会随之被销毁。为了解决循环引用可能导致的内存泄漏问题，可以使用 <code>weak_ptr</code> ，其不会增加引入计数。<code>unique_ptr</code> 拥有所指对象的独占权，并在自身销毁时将其所指向的对象销毁。</p>
<p>在多线程程序中使用 <code>shared_ptr</code> 时，由于涉及引用计数器变化时的同步操作（锁），会增加创建和回收的开销，需谨慎使用，或采用传引用的方式进行调用。</p>
<p>此外，无论是 <code>shared_ptr</code> 还是 <code>unique_ptr</code>，最主要的两种构造方式（以 <code>shared_ptr</code> 为例）是：<code>make_shared</code> 构造和通过 <code>new</code> 构造：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p0 = std::shared_ptr&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>());</span><br><span class="line"><span class="keyword">auto</span> p1 = std::make_shared&lt;T&gt;();</span><br></pre></td></tr></table></figure>

<p>这两种构造方式会带来不同的内存布局：<code>make_shared</code> 能够使得引用计数块和对象在内存上连续，只需要进行一次内存分配；而后者需要先通过 <code>new</code> 分配对象内存，再将对象指针传给 <code>shared_ptr</code> 的构造函数，需要再次额外分配引用计数块，导致内存可能是不连续的。相比 <code>new</code> 的方式，<code>make_shared</code> 能够带来更高的运行效率。并且，通过 <code>new</code> 的方式还可能导致内存泄漏，而 <code>shared_ptr</code> 则是异常安全的。因此，在非特殊情况下，应尽可能使用 <code>make_shared</code> 而不是通过 <code>new</code> 的方式来创建智能指针。</p>
<h2 id="2-3-enable-shared-from-this"><a href="#2-3-enable-shared-from-this" class="headerlink" title="2.3 enable_shared_from_this"></a>2.3 <code>enable_shared_from_this</code></h2><p>在异步编程场景中，一个常见的场景是，需要在类中将该类的对象注册到某个回调类或函数中，此时，不能简单传递 <code>this</code> 指针，因为很可能回调时该对象已经不存在导致空指针访问。若通过智能指针管理对象，也不能直接将 <code>this</code> 指针构造成 <code>shared_ptr</code> ，因为无法通过裸指针获得引用计数块信息，这样构造会造成对象内存的多次释放。</p>
<p>通过裸指针（<code>this</code> 指针）构造智能指针的关键在于得到引用计数信息，为了解决这一问题，标准库提供了 <code>enable_shared_from_this</code> 这一模板基类，通过 <code>CRTP</code>（会在下文介绍） 在父类中存储子类的指针信息和引用计数信息，同时提供了 <code>shared_from_this</code> 和 <code>weak_from_this</code> 接口以获取智能指针。在进行智能指针构造时，通过编译时多态判断被构造的类是否派生自 <code>enable_shared_from_this</code>，如果是，则将相关信息存储到基类中以供后续使用，否则什么也不用做，体现出了 C++ “零成本抽象” 的思想。</p>
<p>在 ClickHouse 中，几乎没有通过裸指针创建对象，将 <code>RAII</code> 与智能指针相结合，较好解决了 C++ 中的资源回收需求。此外，许多类都继承自 <code>enable_shared_from_this</code> 用于在类中获取智能指针，例如，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/39e481934c8cf99fe698c9b5d109d8b9ab2464c6/src/DataTypes/IDataType.h#L53-L74"><code>IDataType</code> 基类</a>，<code>getPtr</code> 方法从类中返回一个智能指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataType</span> :</span> <span class="keyword">private</span> boost::noncopyable, <span class="keyword">public</span> std::enable_shared_from_this&lt;IDataType&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IDataType</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IDataType</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">DataTypePtr <span class="title">getPtr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">shared_from_this</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/39e481934c8cf99fe698c9b5d109d8b9ab2464c6/src/Storages/MergeTree/AsyncBlockIDsCache.cpp#L30-L51">在异步回调函数中使用 <code>shared_from_this</code></a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">xstd::vector&lt;String&gt; <span class="title">AsyncBlockIDsCache::getChildren</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> zookeeper = storage.<span class="built_in">getZooKeeper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> watch_callback = [last_time = <span class="keyword">this</span>-&gt;last_updatetime.<span class="built_in">load</span>()</span><br><span class="line">                           , my_update_min_interval = <span class="keyword">this</span>-&gt;update_min_interval</span><br><span class="line">                           , my_task = task-&gt;<span class="built_in">shared_from_this</span>()](<span class="keyword">const</span> Coordination::WatchResponse &amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">if</span> (now - last_time &lt; my_update_min_interval)</span><br><span class="line">        &#123;</span><br><span class="line">            std::chrono::milliseconds sleep_time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(my_update_min_interval - (now - last_time));</span><br><span class="line">            my_task-&gt;<span class="built_in">scheduleAfter</span>(sleep_time.<span class="built_in">count</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            my_task-&gt;<span class="built_in">schedule</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    std::vector&lt;String&gt; children;</span><br><span class="line">    Coordination::Stat stat;</span><br><span class="line">    zookeeper-&gt;<span class="built_in">tryGetChildrenWatch</span>(path, children, &amp;stat, watch_callback);</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-模板与范型编程"><a href="#3-模板与范型编程" class="headerlink" title="3. 模板与范型编程"></a>3. 模板与范型编程</h1><p>范型编程是 C++ 语言中的重要组成部分，其具有非常高的灵活性，使得我们能够以一种独立于特定类型的方式开发代码，具有更细粒度的静态类型检查，生成的代码通常具有更高的效率。模板是范型编程的基础，C++ 标准库中的各种容器、算法，几乎都离不开模板。现代 C++ 进一步扩展了范型编程的能力，例如变参模板支持、lambda 表达式、concept 引入等；同时，范型编程的产物模板元编程也在现代 C++ 中获得了巨大的成功。</p>
<p>模板与范型编程在 ClickHouse 中具有非常广泛的应用，是 ClickHouse 实现高效代码的关键技术，通过泛型编程实现编译期多态，将部分控制逻辑和计算逻辑从运行时转移到编译时，从而生成性能更优、向量化更好的代码。</p>
<h2 id="3-1-lambda-表达式"><a href="#3-1-lambda-表达式" class="headerlink" title="3.1 lambda 表达式"></a>3.1 lambda 表达式</h2><p>在介绍 lambda 表达式之前，先介绍一下函数对象：一个对象只要能够像函数一样进行调用，即为函数对象，同时，函数对象中可以携带状态。函数对象可以作为参数传递给其他函数，例如标准库 <code>&lt;algorithm&gt;</code> 中的算法都需要提供一个函数对象，另一个比较常见的场景是回调函数。</p>
<p>过去，在 C++ 是通过重载操作符 <code>()</code> 来实现函数对象的，而状态则能够在类中存储，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span> <span class="params">(T x, T y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = add&#123;&#125;(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>此外，标准库提供了高阶函数以支持参数绑定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add10 = std::<span class="built_in">bind</span>(plus&lt;<span class="keyword">int</span>&gt;&#123;&#125;, <span class="number">10</span>, _1);</span><br></pre></td></tr></table></figure>
<p>在这儿，<code>bind</code> 接收一个函数对象进行参数绑定，绑定的参数为 10，而 <code>_1</code> 为来自 <code>std::placeholders</code> 名字空间的占位符，表示在调用时才对该参数进行绑定，最终生成一个只接受一个参数的函数对象 <code>add10</code>，可以直接通过 <code>add10(1)</code> 进行调用。</p>
<p>C++ 11 引入了 <code>lambda</code> 表达式，进一步简化了函数对象的定义，<code>lambda</code> 表达式的背后是编译器会自动生成一个匿名类型并实例化对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获](形参列表) -&gt; 后置返回类型（可省略）&#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<p>从 C++14 起，<code>lambda</code> 表达式支持形参的 <code>auto</code> 类型推导（上文已有提到），因此，上文提到的函数对象实现可以简化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="keyword">auto</span> add10 = [add](<span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">10</span>, y); &#125;;</span><br></pre></td></tr></table></figure>

<p>此外，值得一提的是 C++11 引入的函数适配器 <code>std::function</code>，其作为一个函数模板，能够存储任何可调用的对象（普通函数、lambda 表达式、<code>bind</code> 表达式以及指向成员函数的指针等）。因此，无论函数对象的类型如何，都可以被对应原型的 <code>std::function</code> 存储，拥有统一的类型，因此可以在运行时绑定，实现语义运行时多态，例如 <code>std::function&lt;int(int, int)&gt;</code> 类型可以绑定到任何返回值为 <code>int</code> 类型，参数为两个 <code>int</code> 类型的函数对象。</p>
<p>在 ClickHouse 中，lambda 表达式出现较多的地方是作为高阶函数的参数以及回调函数，同时，通过 <code>std::function</code> 声明回调函数的类型。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> MergeTreeReadTaskCallback = std::function&lt;std::optional&lt;ParallelReadResponse&gt;(ParallelReadRequest)&gt;;</span><br></pre></td></tr></table></figure>
<p>通过该方式定义了一个函数对象类型，之后，可以<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/e708f0d9413a71cb788d3d23731fe379f44fd729/src/Server/TCPHandler.cpp#L418-L432">像使用其他类型一样使用该函数对象类型</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Context::setReadTaskCallback</span><span class="params">(ReadTaskCallback &amp;&amp; callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next_task_callback = callback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TCPHandler.cpp</span></span><br><span class="line">query_context-&gt;<span class="built_in">setMergeTreeReadTaskCallback</span>([<span class="keyword">this</span>](ParallelReadRequest request) -&gt; std::optional&lt;ParallelReadResponse&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Stopwatch watch;</span><br><span class="line">    CurrentMetrics::Increment <span class="built_in">callback_metric_increment</span>(CurrentMetrics::MergeTreeReadTaskRequestsSent);</span><br><span class="line">    std::lock_guard <span class="built_in">lock</span>(task_callback_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state.cancellation_status == CancellationStatus::FULLY_CANCELLED)</span><br><span class="line">        <span class="keyword">return</span> std::nullopt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendMergeTreeReadTaskRequestAssumeLocked</span>(std::<span class="built_in">move</span>(request));</span><br><span class="line">    ProfileEvents::<span class="built_in">increment</span>(ProfileEvents::MergeTreeReadTaskRequestsSent);</span><br><span class="line">    <span class="keyword">auto</span> res = <span class="built_in">receivePartitionMergeTreeReadTaskResponseAssumeLocked</span>();</span><br><span class="line">    ProfileEvents::<span class="built_in">increment</span>(ProfileEvents::MergeTreeReadTaskRequestsSentElapsedMicroseconds, watch.<span class="built_in">elapsedMicroseconds</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这儿，<code>Context</code> 中声明了一个 <code>MergeTreeReadTaskCallback</code> 类型的对象，其能够通过 <code>setMergeTreeReadTaskCallback</code> 方法进行设置，在调用该方法时，可以直接通过一个 lambda 表达式来创建函数对象，只需要保证函数签名与 <code>MergeTreeReadTaskCallback</code> 中的函数签名一致即可。基于函数适配器和 lambda 表达式，使得函数对象的使用和创建更加方便和灵活。</p>
<p>此外，lambda 表达式显著增加了范型编程的吸引力，最常见的用途之一就是作为 STL 算法的参数。例如，在 <code>std::sort</code> 中<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/98e6a6b09b5256731108aac2ff4808cb1783a99f/src/Storages/MergeTree/MergeTreeData.cpp#L1150-L1153">自定义比较函数</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> std::<span class="built_in">sort</span>(nodes.<span class="built_in">begin</span>(), nodes.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; lhs, <span class="keyword">const</span> <span class="keyword">auto</span> &amp; rhs) </span><br><span class="line">&#123;                                                                                                                           </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tie</span>(lhs.info.level, lhs.info.mutation) &gt; std::<span class="built_in">tie</span>(rhs.info.level, rhs.info.mutation);</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>或者，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/98e6a6b09b5256731108aac2ff4808cb1783a99f/src/Functions/FunctionUnaryArithmetic.h#L194-L219">作为范型编程中的模板参数</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">castType</span><span class="params">(<span class="keyword">const</span> IDataType * type, F &amp;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> castTypeToEither&lt;</span><br><span class="line">        DataTypeUInt8,</span><br><span class="line">        DataTypeUInt16,</span><br><span class="line">        DataTypeUInt32,</span><br><span class="line">        DataTypeUInt64,</span><br><span class="line">        DataTypeUInt128,</span><br><span class="line">        DataTypeUInt256,</span><br><span class="line">        DataTypeInt8,</span><br><span class="line">        DataTypeInt16,</span><br><span class="line">        ...</span><br><span class="line">        DataTypeInterval&gt;(type, std::forward&lt;F&gt;(f));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> valid = <span class="built_in">castType</span>(arguments[<span class="number">0</span>].<span class="built_in">get</span>(), [&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp; type)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (!valid)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是 ClickHouse 中 UDF 实现时经常用到的一个方法，在运行时通过函数参数的父类指针动态确定其派生类的具体类型，之后，将类型作为 lambda 函数的参数，在 lambda 表达式中实现具体的执行逻辑。在 <code>castType</code> 这一模板函数中，lambda 表达式作为了模板函数的参数。</p>
<h2 id="3-2-SFINAE"><a href="#3-2-SFINAE" class="headerlink" title="3.2 SFINAE"></a>3.2 SFINAE</h2><p>在谈论模板相关的特性之前，先简单介绍一下 SFINAE，虽然其并不是现代 C++ 才有的东西。<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> 的全称是 “Substitution Failure Is Not An Error”，是用于模板函数重载决议的一条规则，即替换失败不是错误，替换指的是模板形参的替换。</p>
<p>在 C++ 中，函数重载决议过程由多个阶段组成：首先是名称查找，找出同名的函数声明与函数模板，作为候选集；之后，对于候选集中的模板函数，需要进行实例化，即进行模板参数的推导和参数替换，如果替换失败，那么则将对应的模板函数从候选集中删除，但不会产生错误，即 SFINEA；最后，是重载决议的阶段，该阶段会从候选集中找出所有可行函数，并从中挑选出最佳可以函数函数，如果没有找到任何可行函数，此时则会出现编译错误。</p>
<p>最佳可行函数的挑选主要按照下面一些规则进行：</p>
<ol>
<li>函数形参与实参类型最匹配，转换最少的为最佳可行函数</li>
<li>非模板函数优于模板函数</li>
<li>对于多个模板实例，最具体的模板实例最佳</li>
<li>若模板函数具有约束（concept），则选择约束最强的</li>
</ol>
<p>基于 SFINAE 特性，我们可以控制编译期的决策过程，选择预期的版本，同时能够实现编译时的分支判断能力，过去在元编程中被大量使用，主要依赖于 <code>std::enable_if</code>。在 C++17 引入 <code>if constexpr</code> 以及 C++20 引入 concept 约束之后，类似的技巧会逐步被更加先进的元编程技术所替代。</p>
<h2 id="3-3-变参模板"><a href="#3-3-变参模板" class="headerlink" title="3.3 变参模板"></a>3.3 变参模板</h2><p>C++11 引入了变参模板，通过变参模板，能够实例化包含任意长度参数列表的类模板和函数模板，并且能够以类型安全的方式给函数传递任意多个参数。变参模板最常见的例子就是 <code>std::make_shared</code> 和 <code>std::make_unique</code> 的实现，其基本形式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tp, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;Tp&gt; <span class="title">make_shared</span><span class="params">(Args&amp;&amp; ...args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的 lambda 表达式处提到的 <code>castType</code> 的实现中实际上就用到了 <a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/17f37541935bce25e2b200f061baafa4dadb338e/src/Functions/castTypeToEither.h#L8-L12"><code>castTypeToEither</code> 这一模板函数</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts, <span class="keyword">typename</span> T, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">castTypeToEither</span><span class="params">(<span class="keyword">const</span> T * type, F &amp;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((typeid_cast&lt;<span class="keyword">const</span> Ts *&gt;(type) &amp;&amp; <span class="built_in">f</span>(*typeid_cast&lt;<span class="keyword">const</span> Ts *&gt;(type))) || ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个模板函数中，我们可以在 <code>Ts</code> 中指定任意个类型，若参数 <code>type</code> 通过 <code>typeid_cast</code> 能够转换到其中任意一个类型，则将转换得到的类型作为参数传递给函数 <code>f</code>（lambda 表达式）进行处理。通过该模板，能够在运行时动态从基类指针得到具体的派生类类型，如果 <code>Ts</code> 中的任意类型都不是 <code>type</code> 所指向的派生类类型，那么则会返回 <code>false</code>。</p>
<p>在现代 C++ 代码中，变参模板已经被大量使用，然而其缺点是容易导致代码膨胀，N 个参数意味着模板的 N 次实例化。</p>
<h2 id="3-4-Type-Traits-与元编程"><a href="#3-4-Type-Traits-与元编程" class="headerlink" title="3.4 Type Traits 与元编程"></a>3.4 Type Traits 与元编程</h2><p>随着 C++ 的不断发展，编译期求值的重要性不断提高。元编程旨在将计算从运行期转移到编译期，广泛用于在编译期进行数值和类型的计算。最开始，元编程只是模板发展历史中偶然发现的产物，由于没有标准的支持，通过模板实现元编程用起来也很蹩脚，好在现代 C++ 标准的演进过程中不断引入了大量语法糖，使得元编程得以被简化。</p>
<p>我们可以从函数的角度来理解元编程，在函数中，会有参数和返回值，而对于模板元编程，如果以函数的角度来看（元函数），那么参数则为尖括号包裹的模板参数，模板参数通常为类型或常量，返回值则为模板成员，成员可能为数值（通常用 <code>value</code> 表示），或者类型（用 <code>type</code> 表示）。</p>
<h3 id="3-4-1-类型计算"><a href="#3-4-1-类型计算" class="headerlink" title="3.4.1 类型计算"></a>3.4.1 类型计算</h3><p>在类型计算中，运用最广泛的就是类型萃取（Type Traints），通过类型萃取得到类型的组合信息，例如萃取函数类型或者参数、返回值类型信息；对类型退化得到原始类型（前面提到的 <code>decay_t</code>）；进行类型与值，类型与类型之间的映射和变换等。类型萃取的主要目的是获取类型相关的特性（属性），根据这些信息我们能够提供更具针对性的实现，从而编译器能够在多个选择中决策出最优的实现。此外，类型萃取也可以在编译时对类型进行变换，给定任意类型 T，可以给这一类型添加 const 修饰、添加引用或指针等，无任何运行时开销。</p>
<p>标准库 <code>&lt;type_traints&gt;</code> 中的类型特征谓词通常是以 <code>is_</code> 为前缀，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否为整型</span></span><br><span class="line">std::is_integral&lt;T&gt;::value; <span class="comment">// std::is_integral&lt;int&gt;::value == true;</span></span><br><span class="line"><span class="comment">// 是否为浮点型</span></span><br><span class="line">std::is_floating_point&lt;T&gt;::value;</span><br><span class="line"><span class="comment">// 是否为数值类型，即整型或浮点</span></span><br><span class="line">std::is_arithmetic&lt;T&gt;::value;</span><br><span class="line"><span class="comment">// T 和 U 是否为相同类型</span></span><br><span class="line">std::is_same&lt;T, U&gt;::value; <span class="comment">// std::is_same&lt;int, int&gt;::value == true;</span></span><br></pre></td></tr></table></figure>
<p>C++14 引入变量模板（variable template）特性之后，C++17 标准库中为 type traints 预定义了一系列变量模板，从而可以用更简洁的方式来表达上述类型特征：用 <code>_v</code> 来代替 <code>::value</code> 的访问方式。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_same_v = is_same&lt;T, U&gt;::value;</span><br></pre></td></tr></table></figure>
<p>变量模板与类型别名（<code>using</code>）较为相似，不同的是变量模板可以接收模板参数，同时支持特化。</p>
<p>除类型谓词外，标准库中也有用于类型变换的 type traints，即基于已有类型进行修改，得到新的类型，输出类型可以通过 <code>type</code> 类型成员进行访问，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> T1 = std::remove_const&lt;<span class="keyword">const</span> <span class="keyword">int</span>&gt;::type; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">using</span> T2 = std::add_const&lt;<span class="keyword">int</span>&gt;::type; <span class="comment">// const int</span></span><br><span class="line"><span class="keyword">using</span> T3 = std::remove_reference&lt;<span class="keyword">int</span> &amp;&gt;::type; <span class="comment">// int</span></span><br><span class="line"><span class="keyword">using</span> T4 = std::add_lvalue_reference&lt;<span class="keyword">int</span>&gt;::type; <span class="comment">// int &amp;</span></span><br><span class="line"><span class="keyword">using</span> T5 = std::add_rvalue_reference&lt;<span class="keyword">int</span>&gt;::type; <span class="comment">// int &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>从 C++14起，标准库中添加了一序列类型别名，因此可以通过 <code>_t</code> 的方式来访问 <code>::type</code>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">add_lvalue_reference_t</span> = <span class="keyword">typename</span> add_lvalue_reference&lt;T&gt;::type;</span><br></pre></td></tr></table></figure>

<p>此外，标准库中也提供了一些常见辅助类，方便实现其他 type traints，其中，<code>integral_constant</code> 能够将类型与值进行一一对应：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Two = std::integral_constant&lt;<span class="keyword">int</span>, <span class="number">2</span>&gt;;</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(Two::value == <span class="number">2</span>);</span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(std::is_same_v&lt;Two::type, <span class="keyword">int</span>&gt;) </span><br></pre></td></tr></table></figure>
<p>标准库中也提供了一些相应的类型别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> v&gt;</span><br><span class="line"><span class="keyword">using</span> bool_constant = integral_constant&lt;<span class="keyword">bool</span>, v&gt;;</span><br><span class="line"><span class="keyword">using</span> true_type = integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>下面，我们以一个 <a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/b1be646fb1e92374fdb77726ce66e954fd0e0474/src/Common/typeid_cast.h#L51-L64">ClickHouse 中判断一个类型是否为 <code>shared_ptr</code> 的例子</a>来看如何实现 type traints。</p>
<p>首先，定义一个基本模板类，使其返回 <code>false</code>，因此可以直接继承上文提到的 <code>std::false_type</code>，其拥有一个静态成员常量 <code>value</code> 且始终为 <code>false</code>，并且是一个空类，使用继承的方式既能达到<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/ebo">空基类优化</a>的效果，并且能够得到约定的返回结果 <code>value</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_shared_ptr</span> :</span> std::false_type</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之后，定义一个针对 <code>std::shared_ptr&lt;T&gt; </code>特化的版本，继承自 <code>std::true_type</code>，因此当输入是 <code>shared_ptr</code> 类型时能够返回 <code>true</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_shared_ptr</span>&lt;</span>std::shared_ptr&lt;T&gt;&gt; : std::true_type</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，再定义一个变量模板 <code>is_shared_ptr_v</code> 从而能够更方便的访问 <code>value</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_shared_ptr_v = is_shared_ptr&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-数值计算"><a href="#3-4-2-数值计算" class="headerlink" title="3.4.2 数值计算"></a>3.4.2 数值计算</h3><p>在模板元编程中，通过模板特化的方式，来进行数值计算，一个非常常见的例子是计算斐波那契数列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> Fibonacci = Fibonacci&lt;N<span class="number">-1</span>&gt; + Fibonacci&lt;N<span class="number">-2</span>&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">constexpr</span> <span class="keyword">size_t</span> Fibonacci&lt;<span class="number">0</span>&gt; = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">constexpr</span> <span class="keyword">size_t</span> Fibonacci&lt;<span class="number">1</span>&gt; = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(Fibonacci&lt;<span class="number">10</span>&gt; == <span class="number">89</span>);</span><br></pre></td></tr></table></figure>
<p>由于在编译时不允许修改输入的非类型参数，无法简单通过 <code>for</code> 循环对迭代变量进行修改和求值。因此，元编程通过递归的方式解决这类迭代问题，从而只需要在输入参数的基础上进行计算而无需修改原值，递归的边界通过特化进行表达，在上述例子中，当输入为 0 或 1 时，停止递归，直接返回边界结果。</p>
<p>上述例子体现出了模板元编程的基本思想：使用递归代替迭代，使用特化代替分支。这一例子只是为了说明元编程可以做什么，但并不是表达数值算法的好方法，比如通过编译期求值函数（<code>constexpr</code> 函数）可以大大简化元编程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> f0 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> f1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">size_t</span> fn;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fn = f1 + f0;</span><br><span class="line">        f0 = f1;</span><br><span class="line">        f1 = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(<span class="built_in">fibonacci</span>(<span class="number">10</span>) == <span class="number">89</span>);</span><br></pre></td></tr></table></figure>
<p>因此，函数依然是用于求值的最佳方式，即使是在编译期，而模板元编程最好只用于计算新的类型和控制结构。</p>
<p><code>constexpr</code> 修饰表示函数可能在编译期求值，只要参数合适，那么编译器将会尝试求值，而 C++20 进一步引入了 <code>consteval</code>，使用 <code>consteval</code> 修饰时要求函数必须能够被编译时求值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">consteval</span> <span class="keyword">ssize_t</span> <span class="title">formatStringCountArgsNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// It does not count named args, but we don&#x27;t use them</span></span><br><span class="line">    <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i + <span class="number">1</span> &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] == <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (str[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/// Ignore checks for complex formatting like &quot;&#123;:.3f&#125;&quot;</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ClickHouse 的日志输出字符串中，使用 <code>&#123;&#125;</code> 作为参数的占位符，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/b3319f790812f983a3d5ee0710d5da975ca4f77f/src/Common/LoggingFormatStringHelpers.h#L144-L167"><code>formatStringCountArgsNum</code> 为计算字符串中参数个数的函数</a>，使用 <code>consteval</code> 修饰意味着该函数必须在编译时被求值。</p>
<p>此外，<code>constexpr</code> 和 <code>consteval</code> 修饰的函数<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/consteval">意味着函数是内联的</a>。</p>
<h3 id="3-4-3-再谈-constexpr"><a href="#3-4-3-再谈-constexpr" class="headerlink" title="3.4.3 再谈 constexpr"></a>3.4.3 再谈 <code>constexpr</code></h3><p><code>constexpr</code> 的引入是为了实现编译时计算的类型安全，同时直接支持元编程，而非模板元编程。</p>
<p>通过 <code>constexpr</code> 定义的常量，通常可以代替使用宏定义的常量，既能够保证类型安全，且无运行时开销。<code>constexpr</code> 定义的变量要求表达式能够在编译时求值，并且拥有 <code>const</code> 属性。而前面已经提到过的 <code>constexpr</code> 函数更好地支持了编译期计算，相比于基于模板的编译期计算，可读性更高，使编译期编程更接近于“普通编程”。</p>
<p>除定义 <code>constexpr</code> 变量和 <code>constexpr</code> 函数之外， C++17 引入了 <code>if constexpr</code> 语句，与普通的 if 语句相比，其会在编译时对布尔常量进行评估，生成对应分支的代码。引入 <code>if constexpr</code> 之后，能够比较清晰地处理编译时的分支选择问题， 进一步简化了模板编程。过去，则需要通过模板特化或 <code>enable_if</code> 等方式来实现，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 默认实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> f&lt;T1&gt;(T1  arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 针对 T1 类型的特定实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">void</span> f&lt;T2&gt;(T2  arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 针对 T2 类型的特定实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而有了 <code>if constexpr</code> 之后，我们能够用更简洁的方式实现上述代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span><span class="params">(std::is_same_v&lt;T, T1&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 针对 T1 类型的特定实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span>(std::is_same_v&lt;T, T2&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        针对类型 T2 的特定实现</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 默认实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>if constexpr</code> 控制结构在 ClickHouse 的常量函数实现中具有非常多的应用，在进行计算时，通常需要对不同的数据类型进行分派，提供不同的计算逻辑。例如，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/b3319f790812f983a3d5ee0710d5da975ca4f77f/src/Functions/abs.cpp#L15-L27"><code>abs</code> 函数的计算</a>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> NO_SANITIZE_UNDEFINED ResultType <span class="title">apply</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_decimal&lt;A&gt;)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> a &lt; <span class="title">A</span><span class="params">(<span class="number">0</span>)</span> ? <span class="title">A</span><span class="params">(-a)</span> : a;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span> (is_big_int_v&lt;A&gt; &amp;&amp; is_signed_v&lt;A&gt;)</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span> (is_integer&lt;A&gt; &amp;&amp; is_signed_v&lt;A&gt;)</span><br><span class="line">        <span class="keyword">return</span> a &lt; <span class="number">0</span> ? <span class="keyword">static_cast</span>&lt;ResultType&gt;(~a) + <span class="number">1</span> : <span class="keyword">static_cast</span>&lt;ResultType&gt;(a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span> (is_integer&lt;A&gt; &amp;&amp; is_unsigned_v&lt;A&gt;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ResultType&gt;(a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span> (std::is_floating_point_v&lt;A&gt;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ResultType&gt;(std::<span class="built_in">abs</span>(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述函数中，控制结构中的表达式均为编译期常量布尔表达式，编译时会根据不同的模板类型生成不同的代码，函数中实际不会包含分支跳转语句，并且函数是 inline 的，不会出现函数调用，因此最终生成的代码对向量化更加友好。</p>
<h3 id="3-4-4-constinit"><a href="#3-4-4-constinit" class="headerlink" title="3.4.4 constinit"></a>3.4.4 <code>constinit</code></h3><p>C++20 进一步引入了 <code>constinit</code> 变量，其同样要求在编译时能够对表达式求值，但同时保留了可变的属性。</p>
<p><code>constinit</code> 的引入是为了解决 C++ 各个编译单元全局变量运行时初始化顺序不确定的问题，若这些全局变量存在依赖，那么初始化结果就是未定义的。过去，该问题常见的解决方案是使用局部静态变量代替全局变量，将依赖转变为对函数的依赖，通过控制函数的调用顺序确保局部静态变量的初始化顺序。通过 <code>constinit</code> 解决了变量运行时初始化顺序不确定的问题，其要求全局声明周期的变量在编译时进行初始化，既能节省运行时初始化的开销，又避免了依赖问题。</p>
<h3 id="3-4-5-std-enable-if"><a href="#3-4-5-std-enable-if" class="headerlink" title="3.4.5 std::enable_if"></a>3.4.5 <code>std::enable_if</code></h3><p>在 C++ 早期元编程历史中，对 SFINAE 有非常高的依赖，从 C++11 起，标准库进一步提供了 <code>std::enable_if</code>，其主要用于 SFINAE 场景中，通过对模板函数、模板类中的模板类型进行谓词判断，从而使程序能够选择合适的模板函数重载版本或模板类特化版本。</p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if</code></a> 接受两个模板参数，第一个参数为布尔条件，第二个参数为类型，当条件为真时，成员 <code>type</code> 为第二个模板参数，当条件为假时，不存在 <code>type</code> 成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span>, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct enable_if &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">enable_if</span>&lt;</span><span class="literal">true</span>, T&gt; &#123; <span class="keyword">using</span> type = T; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="keyword">typename</span> T = <span class="keyword">void</span> &gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">enable_if_t</span> = <span class="keyword">typename</span> enable_if&lt;B,T&gt;::type; <span class="comment">// C++14</span></span><br></pre></td></tr></table></figure>

<p>在没有 <code>if constexpr</code> 和 concept 之前，<code>std::enable_if</code> 在元编程中被大量使用，例如，这是过去 ClickHouse 中的某函数的声明和实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;std::is_same_v&lt;T, <span class="keyword">int8_t</span>&gt;</span><br><span class="line">                                        || std::is_same_v&lt;T, <span class="keyword">int16_t</span>&gt;</span><br><span class="line">                                        || std::is_same_v&lt;T, <span class="keyword">int32_t</span>&gt;, T&gt;::type * = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">static</span> ReturnType <span class="built_in">apply</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;!std::is_same_v&lt;T, <span class="keyword">int8_t</span>&gt;</span><br><span class="line">                                              &amp;&amp; !std::is_same_v&lt;T, <span class="keyword">int16_t</span>&gt;</span><br><span class="line">                                              &amp;&amp; !std::is_same_v&lt;T, <span class="keyword">int32_t</span>&gt;</span><br><span class="line">                                              &amp;&amp; !std::is_same_v&lt;T, <span class="keyword">int64_t</span>&gt;, T&gt;::type * = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">static</span> ReturnType <span class="built_in">apply</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将 <code>std::enable_if</code> 与 type traits 结合，能够对模板类型进行限制，根据模板类型选择合适的实现。上述例子中，根据 <code>enable_if</code>，我们无需查看函数实现，就能够从函数声明中直接看出两个模板函数的类型作用范围。</p>
<p>然而，<code>enable_if</code> 的问题在于与模板声明混杂在一起，降低了代码的可读性，还会导致难以分辨出完整的模板参数，例如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ReturnType = <span class="keyword">void</span>, <span class="keyword">typename</span> CheckForNull, <span class="keyword">typename</span> DeserializeNested, <span class="keyword">typename</span> std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;ReturnType, <span class="keyword">bool</span>&gt;, ReturnType&gt;* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">static</span> ReturnType <span class="built_in">safeDeserialize</span>(</span><br><span class="line">        IColumn &amp; column, <span class="keyword">const</span> ISerialization &amp;,</span><br><span class="line">        CheckForNull &amp;&amp; check_for_null, DeserializeNested &amp;&amp; deserialize_nested)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述 <code>apply</code> 模板函数，通过 <code>if constexpr</code> 能够更清晰的进行表达：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tempalte&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ReturnType <span class="title">apply</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;T, <span class="keyword">int8_t</span>&gt; ||</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::is_same_v&lt;T, <span class="keyword">int16_t</span>&gt; ||</span></span></span><br><span class="line"><span class="params"><span class="function">                  std::is_same_v&lt;T, <span class="keyword">int32_t</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...                  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在 C++20 引入 concept 之后，我们<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/pull/52898">可以使用更简洁、可读性更高的方式来代替 <code>enable_if</code></a>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> * =</span> <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">requires</span> std::same_as&lt;T, <span class="keyword">int8_t</span>&gt; || std::same_as&lt;T, <span class="keyword">int16_t</span>&gt; || <span class="function">std::same_as&lt;T, <span class="keyword">int32_t</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ReturnType <span class="title">apply</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span> * =</span> <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="built_in"><span class="keyword">requires</span></span>(!std::same_as&lt;T, <span class="keyword">int8_t</span>&gt; &amp;&amp; !std::same_as&lt;T, <span class="keyword">int16_t</span>&gt; &amp;&amp; !std::same_as&lt;T, <span class="keyword">int32_t</span>&gt;)</span><br><span class="line"><span class="function"><span class="keyword">static</span> ReturnType <span class="title">apply</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-concept-约束"><a href="#3-5-concept-约束" class="headerlink" title="3.5 concept 约束"></a>3.5 concept 约束</h2><p>长期以来，C++ 的模板参数没有任何约束，仅仅在实例化时才能够发现类型上的错误，这导致一方面，编译错误信息非常难以看懂，另一方面，在阅读模板元编程的代码时，面对大量的模板参数，在不深入实现的情况下，难以理解具体是干什么的。语言上的缺陷导致后续产生了 <code>std::enable_if</code> 等变通方法，但其仍然不能真正解决问题，直到 concept 的出现。concept 的引入大大降低了元编程的难度，同时简化了范型编程。</p>
<p>在上文中，已经多次提到 concept，concept 是一个对类型进行约束的编译期谓词（也可以简单理解成是一个布尔表达式常量），给定一个类型，判断其是否满足语法和语义要求。从 C++ 很早期的发展开始，就已经不断有关于概念的讨论，但由于各种原因，直到 C++20 才被正式标准化。</p>
<h3 id="3-5-1-concept-定义"><a href="#3-5-1-concept-定义" class="headerlink" title="3.5.1 concept 定义"></a>3.5.1 concept 定义</h3><p>concept 主要可以通过两种方式进行定义。第一种方式是使用 type traits 来进行定义，此时，概念被定义为一个约束表达式（布尔表达式常量）。例如，下面的代码定义了名为 <code>floating_point</code> 的 concept，在判断类型是否满足 concept 约束时，编译器会对 concept 定义的约束表达式进行求值，因此可以通过静态断言检测类型是否满足要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> floating_point = is_floating_point_v&lt;T&gt;; </span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(floating_point&lt;<span class="keyword">float</span>&gt;);</span><br></pre></td></tr></table></figure>
<p>concept 也支持通过逻辑操作符（逻辑与和逻辑或）进行组合以定义更复杂的概念：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> int_or_float = is_same_v&lt;<span class="keyword">int</span>, T&gt; || is_same_v&lt;<span class="keyword">float</span>, T&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> large_int = is_integral_v&lt;T&gt; &amp;&amp; (<span class="built_in"><span class="keyword">sizeof</span></span>(T) &gt;= <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(int_or_float&lt;<span class="keyword">float</span>&gt;); <span class="comment">//第一个表达式为假，但第二个为真，整体为真</span></span><br><span class="line"><span class="built_in"><span class="keyword">static_assert</span></span>(large_int&lt;<span class="keyword">long</span>&gt;);</span><br></pre></td></tr></table></figure>
<p>但逻辑操作符在约束表达式中的语义相对布尔运算有细微区别，主要体现在变参模板构成的约束表达式，其既不是约束合取，也不是约束析取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">concept</span> has_integral_type = (is_integral_v&lt;<span class="keyword">typename</span> Ts::type&gt; || ...);</span><br></pre></td></tr></table></figure>
<p>上述 concept 不是析取表达式，因此没有短路操作，其首先检查整个表达式是否合法，这要求每一个模板参数都有类型成员 <code>type</code>，否则整个表达式为假。若要表达至少一个模板参数存在类型成员 <code>type</code> 并且为整型，可以通过添加一层间接层解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> has_nested_integral_type = is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="keyword">concept</span> has_integral_type = (has_nested_integral_type&lt;Ts&gt; || ...);</span><br></pre></td></tr></table></figure>

<p>下面的 concept 定义是一个支持短路的析取表达式，表示要求存在一个模板参数拥有整型类型成员 <code>type</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> has_integral_type = is_integral_v&lt;<span class="keyword">typename</span> T::type&gt; || is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;;</span><br></pre></td></tr></table></figure>

<p>若要检查逻辑表达式的合法性，即是否都包含 <code>type</code> 成员，则需要写成如下形式，其要求两个模板参数都拥有 <code>type</code> 成员，且至少其中一个为整型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> has_integral_type = <span class="built_in"><span class="keyword">bool</span></span>(is_integral_v&lt;<span class="keyword">typename</span> T::type&gt; || is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;);</span><br></pre></td></tr></table></figure>

<p>同理，对于逻辑否定的情况，<code>c1</code> 要求类型 <code>T</code> 存在类型成员 <code>type</code> 且必须为整型，而 <code>c2</code> 要求 <code>T</code> 不存在关联类型或关联类型不为整型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> c1 = is_integral_v&lt;<span class="keyword">typename</span> T::type&gt;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> c2 = (!is_integral_v&lt;typenamt T::type&gt;);</span><br></pre></td></tr></table></figure>

<p>除使用 type traits 外，另一种定义 concept 的语法是使用 requires 表达式，用于表达模板参数及其对象的特征要求：成员函数、自由函数和关联类型等。requires 表达式的基本语法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">requires</span></span> (形参列表，可选)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 一系列表达式要求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>requires 表达式的结果为布尔类型，为编译期谓词，当进行求值时，会按表达式体中声明的先后顺序依次检查表达式的合法性，只有所有要求都合法，才返回真，否则为假。</p>
<p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/requires">requires 表达式提供四种形式的要求</a>：</p>
<ul>
<li>简单要求：任意表达式，不以 requires 开头，表示表达式需要是合法的（仅检查合法性，不会进行评估），例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> addable = <span class="built_in"><span class="keyword">requires</span></span> (T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">    a + b; <span class="comment">// 要求 a + b 是一个合法的表达式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> is_a_animal = <span class="built_in"><span class="keyword">requires</span></span> (T a)</span><br><span class="line">&#123;</span><br><span class="line">    a::name;  <span class="comment">// 具有静态成员 name</span></span><br><span class="line">    a.age;  <span class="comment">//  具有成员变量 age</span></span><br><span class="line">    a.<span class="built_in">bark</span>(); <span class="comment">// 具有 bark 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类型要求：以 <code>typename</code> 开头，后跟一个类型名，要求类型是合法的，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> c = <span class="keyword">requires</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typename</span> T::type; <span class="comment">// 存在类型成员 type</span></span><br><span class="line">    <span class="keyword">typename</span> std::vector&lt;T&gt;; <span class="comment">// 能够实例化 vector</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复合要求：复合要求可以进一步指定表达式的返回类型，是否会抛出异常等，基本语法为：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;表达式&#125; <span class="built_in">noexcepct</span>(可选) -&gt; 返回类型要求(可选)</span><br></pre></td></tr></table></figure>
例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> c = <span class="built_in"><span class="keyword">requires</span></span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    &#123;*x&#125; -&gt; std::convertible_to&lt;<span class="keyword">typename</span> T::inner&gt;; <span class="comment">//</span></span><br><span class="line"> </span><br><span class="line">    &#123;x + <span class="number">1</span>&#125; -&gt; std::same_as&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在上述例子中，<code>std::same_as</code> 和 <code>std::convertible_to</code> 是标准库中定义的两个 concept，concept 会将表达式类型补充到 concept 的第一个参数中，因此省略了第一个参数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> same_as = ...;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">concept</span> convertible_to = ...;</span><br></pre></td></tr></table></figure>
上文提到的 <code>HasPrefetchMemberFunc</code> 就是一个最简单的复合要求，其和简单要求几乎没有区别，只是使用大括号将表达式括起来了：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> HashTable, <span class="keyword">typename</span> KeyHolder&gt;</span><br><span class="line"><span class="keyword">concept</span> HasPrefetchMemberFunc = <span class="keyword">requires</span></span><br><span class="line">&#123;</span><br><span class="line">    &#123;std::declval&lt;HashTable&gt;().<span class="built_in">prefetch</span>(std::declval&lt;KeyHolder&gt;())&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>嵌套要求：其支持在表达式体中通过 requires + 约束表达式来表达额外的约束，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> c = <span class="keyword">requires</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="built_in"><span class="keyword">sizeof</span></span>(T) &gt; <span class="built_in"><span class="keyword">sizeof</span></span>(T*);   <span class="comment">// T 的大小大于 T* 的大小</span></span><br><span class="line">    &#123; T.<span class="built_in">func</span>() &#125; <span class="keyword">noexcept</span> -&gt; std::same_as&lt;<span class="keyword">int</span>&gt;; <span class="comment">// 具有 func() 方法，不会抛出异常，返回类型为 int</span></span><br><span class="line">    <span class="keyword">typename</span> T::type; <span class="comment">// 具有 type 成员类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
例如，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/ed8d2da31f49461e19fa4df79da624d2589f0896/src/Common/Concepts.h#L12-L16">ClickHouse 中定义了名为 <code>OptionalAgument</code> 的 concept</a>，其要求变参模板中的模板参数个数只能为 0 或 1：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">concept</span> OptionalArgument = <span class="built_in"><span class="keyword">requires</span></span>(T &amp;&amp;...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">requires</span></span>(<span class="keyword">sizeof</span>...(T) == <span class="number">0</span> || <span class="keyword">sizeof</span>...(T) == <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>另外，需要注意的是简单要求和嵌套要求中对布尔表达式的约束是不一样的，前者只检查表达式的合法性，而后者需要在合法性基础上求值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> c = <span class="keyword">requires</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">sizeof</span></span>(T) &lt;= <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); <span class="comment">// 始终为真</span></span><br><span class="line">    <span class="function"><span class="keyword">requires</span> <span class="title">sizeof</span><span class="params">(T)</span> &lt;</span>= <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>); <span class="comment">// 要求 T 的大小小于等于 int 的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-5-2-concept-使用"><a href="#3-5-2-concept-使用" class="headerlink" title="3.5.2 concept 使用"></a>3.5.2 concept 使用</h2><p>通过使用 requires 子句，能够为模板类或模板函数的模板参数添加约束，例如，下面的代码是 <a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/72f7134fa36b53ac5f9f52e0964ee6595f69c75c/src/Functions/roundToExp2.cpp#L23-L35">ClickHouse 中用于计算将输入值舍去到 2 的幂次的模板函数</a>，其针对不同的类型提供了不同的实现，使用 requires 子句进行约束，在没有 concept 之前，只能使用晦涩难懂的 <code>enable_if</code> 来实现这一功能（或者使用 C++17 引入的 <code>if constexpr</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">requires</span> std::is_integral_v&lt;T&gt; &amp;&amp; (<span class="built_in"><span class="keyword">sizeof</span></span>(T) == <span class="built_in"><span class="keyword">sizeof</span></span>(UInt64))</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">roundDownToPowerOfTwo</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;= <span class="number">0</span> ? <span class="number">0</span> : (<span class="built_in">T</span>(<span class="number">1</span>) &lt;&lt; (<span class="number">63</span> - __builtin_clzll(x)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::is_same_v&lt;T, Float32&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">roundDownToPowerOfTwo</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bit_cast&lt;T&gt;(bit_cast&lt;UInt32&gt;(x) &amp; ~((<span class="number">1ULL</span> &lt;&lt; <span class="number">23</span>) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::is_same_v&lt;T, Float64&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">roundDownToPowerOfTwo</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bit_cast&lt;T&gt;(bit_cast&lt;UInt64&gt;(x) &amp; ~((<span class="number">1ULL</span> &lt;&lt; <span class="number">52</span>) - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> is_big_int_v&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">roundDownToPowerOfTwo</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Exception</span>(ErrorCodes::NOT_IMPLEMENTED, <span class="string">&quot;roundToExp2() for big integers is not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行模板函数的重载决议时，会根据 concept 的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constraints#Requires_clauses">偏序规则</a> 选择满足条件的约束最强的函数。</p>
<p>除了 requires 子句之外，一些简单情况下，也可以使用更简洁的语法来引入约束，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::integral T, std::integral U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T, U)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>typename</code> 关键字替换成了 <code>std::integral</code> 这一 concept，对多个模板参数添加 concept 约束，等价于一个约束合取表达式，即上述例子等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">requires</span> <span class="params">(std::integral&lt;T&gt; &amp;&amp; std::integral&lt;U&gt;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T, U)</span></span></span><br></pre></td></tr></table></figure>
<p>此外，概念约束也可以用于 <code>auto</code> 参数推导中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(std::integral <span class="keyword">auto</span> a, std::integral <span class="keyword">auto</span> b)</span></span>; <span class="comment">// 普通函数 auto 类型约束</span></span><br><span class="line"><span class="keyword">auto</span> f = [] (std::integral <span class="keyword">auto</span> lhs, std::integral <span class="keyword">auto</span> rhs) &#123; <span class="keyword">return</span> lhs + rhs; &#125;; <span class="comment">// lambda 约束</span></span><br></pre></td></tr></table></figure>
<p>不过这样的使用方式可能会使 C++ 代码看起来越来越魔幻。</p>
<p>在 ClickHouse 的代码中，<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/pull/52898">基本上过去所有使用 <code>std::enable_if</code> 来实现 SFINAE 的地方都已经替换成了更加简洁、代码更加清晰的 concepts 约束</a>。</p>
<h2 id="3-6-CRTP-与编译期多态"><a href="#3-6-CRTP-与编译期多态" class="headerlink" title="3.6 CRTP 与编译期多态"></a>3.6 CRTP 与编译期多态</h2><p>在介绍 <code>std::enable_shared_from_this</code> 时，我们已经提到过 CRTP，其全称是<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/crtp">奇异递归模版模式（Curiously Recurring Template Pattern）</a>。CRTP 是 C++ 模板编程中非常常用的一种方法，其将派生类作为基类的模板参数，从而让基类可以使用派生类提供的方法。CRTP 并不是现代 C++ 才有的东西，但其在 ClickHouse 中具有非常广泛的应用，因此在此进行简要介绍。</p>
<p>CRTP 主要有两方面的用途：</p>
<ul>
<li>代码复用：子类派生自模板基类，可以复用基类的方法；</li>
<li>编译期多态：由于基类是一个模板类，派生类是基类的模板参数，因此基类可以调用派生类中的方法，从而实现静态多态，与运行时多态相比，没有虚函数调用开销。</li>
</ul>
<p>CRTP 的基本形式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;Derived&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>例如，前面提到的 <code>std::enable_shared_from_this</code> 在 ClickHouse 中被大量应用，都依赖于 CRTP。<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/c0a43df749c827ce13abb015faca4ad8ab524685/src/Storages/IStorage.h#L87-L94"><code>IStorage</code> 是 ClickHouse 中用于描述一个表（table）的接口类</a> ，其继承自三个基类，并且都使用了 CRTP；此外，用于描述一个数据类型的 <code>IDataType</code>，用于描述一个数据库的 <code>IDatabase</code>，用于描述一个聚合函数实现的 <code>IAggregateFunction</code> 等都通过 CRTP 继承自 <code>std::enable_shared_from_this</code>，而用于描述一个列的 <code>IColumn</code> 通过 CRTP 继承自 <code>COW</code> 基类用于实现 Copy-On-Write。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IStorage</span> :</span> <span class="keyword">public</span> std::enable_shared_from_this&lt;IStorage&gt;, <span class="keyword">public</span> TypePromotion&lt;IStorage&gt;, <span class="keyword">public</span> IHints&lt;<span class="number">1</span>, IStorage&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDataType</span> :</span> <span class="keyword">private</span> boost::noncopyable, <span class="keyword">public</span> std::enable_shared_from_this&lt;IDataType&gt; &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IDatabase</span> :</span> <span class="keyword">public</span> std::enable_shared_from_this&lt;IDatabase&gt; &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IAggregateFunction</span> :</span> <span class="keyword">public</span> std::enable_shared_from_this&lt;IAggregateFunction&gt;, <span class="keyword">public</span> IResolvedFunction &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWLockImpl</span> :</span> <span class="keyword">public</span> std::enable_shared_from_this&lt;RWLockImpl&gt; &#123; ... &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IColumn</span> :</span> <span class="keyword">public</span> COW&lt;IColumn&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>CRTP 实现静态多态的关键在于基类能够在编译期获得派生类的类型，因此能够在编译时对派生类的函数进行派发，与基于虚函数的动态多态相比，一方面，省去了间接访址的开销；另一方面，更容易实现函数的内联，从而消除函数调用，利于实现向量化执行。</p>
<p>基于上述思想，在 ClickHouse 中，一些通用算子例如一元运算、二元运算的实现，利用模板（结合元编程） + 编译期多态技术，既实现了代码复用，又充分保证了算子的向量化执行。这儿说的通用算子指的是 <a href="https://ucasfl.github.io/2020/12/25/How-to-Implement-User-defined-functions-in-ClickHouse/">ClickHouse 中的普通函数</a>，其对于一行输入产生一行对应的输出。</p>
<p>以一元运算为例，一元运算包括取绝对值(abs)、取反(negate)、位移等，这些不同的一元运算都是对于一列输入的每一行数据产生一个输出，最主要的区别仅在于对每一行数据的计算逻辑上。因此，为了实现代码复用，我们可以把一元运算抽象成一个统一的类，再通过派发的方式分别实现不同的一元运算。若基于动态分派的方式实现，那么实现逻辑可能如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionUnaryArithmetic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ColumnPtr <span class="title">executeImpl</span><span class="params">(Argument &amp; arguments)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ColumnPtr res;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">size_t</span> col_size = arguments[<span class="number">0</span>].column-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 对输入列的每一行数据分别进行计算产生一个输出，然而由于虚函数调用，for 循环计算无法向量化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; col_size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = <span class="built_in">apply</span>(arguments[<span class="number">0</span>].column[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类继承并实现 apply 函数，其中实现具体计算逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ResultType <span class="title">apply</span><span class="params">(T a)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbsFunction</span>:</span> <span class="keyword">public</span> FunctionUnaryArithmetic</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ResultType <span class="title">apply</span><span class="params">(T a)</span> <span class="keyword">override</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，基于动态分派的方式，尽管实现了代码复用，但是由于出现虚函数调用，导致核心计算逻辑无法实现向量化。因此，需要转向静态分派的方式来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Op&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionUnaryArithmetic</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ColumnPtr <span class="title">executeImpl</span><span class="params">(Argument &amp; arguments)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ColumnPtr res;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">size_t</span> col_size = arguments[<span class="number">0</span>].column-&gt;<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 对输入列的每一行数据分别进行计算产生一个输出，算子具体实现逻辑类作为模板参数，</span></span><br><span class="line">        <span class="comment">// 可以在编译时对算子实现方法进行分派，消除虚函数调用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; col_size; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = Op::<span class="built_in">apply</span>(arguments[<span class="number">0</span>].column[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbsImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> ResultType <span class="title">apply</span><span class="params">(T a)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在基于静态分派的实现中，将 <code>FunctionUnaryArithmetic</code> 抽象成了一个模板类，模板参数是每一种一元运算的具体实现，因此，能够在编译时实现对一元运算的静态分派，消除了虚函数调用，并且 <code>apply</code> 函数能够被内联，从而实现核心计算逻辑的向量化执行。ClickHouse 中的<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/269c82a612e1d0d9224af4fc18cad3660af40fe8/src/Functions/FunctionUnaryArithmetic.h#L184-L559">一元运算</a>、<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/blob/269c82a612e1d0d9224af4fc18cad3660af40fe8/src/Functions/FunctionBinaryArithmetic.h#L750-L2481">二元运算</a>等常量函数正是基于上述静态分派的方式来实现的，其中也大量依赖了 type traits、<code>if constexpr</code> 等元编程手段来实现控制逻辑。</p>
<p>基于静态分派的方式，实现了代码复用，保证了性能，同时代码也具有良好的可扩展性，例如，当我们要<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/pull/19527">基于上述一元运算框架实现 <code>sign</code> 这一函数时</a>，主要逻辑只需要实现 <code>apply</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SignImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">using</span> ResultType = Int8;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> allow_fixed_string = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> NO_SANITIZE_UNDEFINED ResultType <span class="title">apply</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(IsDecimalNumber&lt;A&gt; || std::is_floating_point_v&lt;A&gt;)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">return</span> a &lt; <span class="title">A</span><span class="params">(<span class="number">0</span>)</span> ? -1 : a =</span>= <span class="built_in">A</span>(<span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span> (is_signed_v&lt;A&gt;)</span><br><span class="line">            <span class="keyword">return</span> a &lt; <span class="number">0</span> ? <span class="number">-1</span> : a == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span> (is_unsigned_v&lt;A&gt;)</span><br><span class="line">            <span class="keyword">return</span> a == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_EMBEDDED_COMPILER</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> compilable = <span class="literal">false</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h1><h2 id="4-1-variant、optional-以及-any"><a href="#4-1-variant、optional-以及-any" class="headerlink" title="4.1 variant、optional 以及 any"></a>4.1 <code>variant</code>、<code>optional</code> 以及 <code>any</code></h2><p>在 C 语言中，可以用 <code>union</code> 来实现不同类型在内存中的“分时共享”，然而，其面临的问题是，没有编译期和运行期的检查确保这个地址仅用作其真实指代的类型，需要由用户自己确保 <code>union</code> 在成员使用上的一致。</p>
<p>C++17 引入了 <code>std::variant</code>、<code>std::optional</code> 和 <code>std::any</code> 消除了 <code>union</code> 存在的问题：</p>
<ul>
<li><code>std::variant&lt;T, U&gt;</code>：持有 T 或 U（变参模板）；</li>
<li><code>std::optional&lt;T&gt;</code>：持有 T 或什么都不持有；</li>
<li><code>std::any</code>：持有任意类型；</li>
</ul>
<p>然而，上述三个特性当前存在的问题在于访问接口的不统一：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;<span class="keyword">int</span>&gt; var1 = <span class="number">7</span>;</span><br><span class="line">std::variant&lt;<span class="keyword">int</span>,string&gt; var2 = <span class="number">7</span>;</span><br><span class="line">std::any var3 = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x1 = *var1 ; <span class="comment">// 对 optional 解引用</span></span><br><span class="line"><span class="keyword">auto</span> x2 = std::get&lt;<span class="keyword">int</span>&gt;(var2); <span class="comment">// 像访问 tuple 一样访问 variant</span></span><br><span class="line"><span class="keyword">auto</span> x3 = std::any_cast&lt;<span class="keyword">int</span>&gt;(var3); <span class="comment">// 转换 any</span></span><br></pre></td></tr></table></figure>
<p>在不久的将来，有望在 C++ 中通过函数式编程风格的模式匹配更加优雅地解决 <code>union</code> 的问题。</p>
<h2 id="4-2-“飞船运算符”"><a href="#4-2-“飞船运算符”" class="headerlink" title="4.2 “飞船运算符”"></a>4.2 “飞船运算符”</h2><p>C++20 引入了三路比较操作符 <code>&lt;=&gt;</code>（由于很像星球大战中的一款飞船，因此也叫飞船运算符）， 用于<a target="_blank" rel="noopener" href="https://github.com/ClickHouse/ClickHouse/pull/52509">简化自定义比较运算符的实现</a>。例如，过去在实现比较运算符时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RowNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UInt64 block = <span class="number">0</span>;</span><br><span class="line">    UInt64 row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> RowNumber &amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> block &lt; other.block</span><br><span class="line">            || (block == other.block &amp;&amp; row &lt; other.row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> RowNumber &amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> block == other.block &amp;&amp; row == other.row;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;= (<span class="keyword">const</span> RowNumber &amp; other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> &lt; other || *<span class="keyword">this</span> == other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要分别实现每一个需要的比较符号，而引入三路比较符之后，只需要一行简单的代码即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RowNumber</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UInt64 block = <span class="number">0</span>;</span><br><span class="line">    UInt64 row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">operator</span> &lt;=&gt;(<span class="keyword">const</span> RowNumber &amp;) <span class="keyword">const</span> = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译器能够帮我们实现 6 个正确的比较操作符。此外，<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/default_comparisons">C++20 还提出了强有序、弱有序等概念</a>，三路比较符默认返回类型为强有序。</p>
<p>在使用三路比较符时，需要注意的是，这 6 个运算符实际上分为了两类：</p>
<ul>
<li>equality operators (==, !=)</li>
<li>ordering operators (&lt;=&gt;, &lt;, &gt;, &lt;=, &gt;=)</li>
</ul>
<p>因此，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/60681266/three-way-comparison-replaces-all-others-comparison-operators-except">在实现 <code>&lt;=&gt;</code> 时，编译器实际上只会为我们实现 4 个 排序运算符，若需要等值运算符，我们还需要实现一个 <code>==</code> 运算符。只有 <code>&lt;=&gt;</code> 是 <code>default</code> 实现时，会同时生成 default <code>==</code>，这也是为什么上面的例子不需要实现 <code>==</code> 的原因。</a></p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>本文主要介绍了部分从 C++11 开始的常见现代 C++ 语言特性及其在 ClickHouse 中的应用。然而，由于现代 C++ 特性浩如烟海，因此还有大量已经在 ClickHouse 中广泛使用但本文没有介绍的现代 C++ 特性，例如并发（内存模型、线程和锁、<code>std::future</code> 等）、文件系统（<code>std::filesystem</code>）、异常（<code>noexcept</code>）和范围（<code>ranges</code> 库）等，除此之后，一些非常重要，但当前还没有在 ClickHouse 中使用到的现代 C++ 特性（据我所知），例如模块、协程等，本文也未涉足。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ClickHouse/" rel="tag">ClickHouse</a></li></ul>


    </footer>
  </div>
  
    
<ul id="article-nav" class="nav nav-pills nav-justified">
  
  <li role="presentation">
    <a href="/2023/03/28/AST-based-Query-Fuzzer-in-ClickHouse/" id="article-nav-older" class="article-nav-link-wrap">
      <i class="fa fa-chevron-left pull-left"></i>
      <span class="article-nav-link-title">AST-based Query Fuzzer in ClickHouse</span>
    </a>
  </li>
  
  
</ul>


  
</article>




        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2023/09/11/Learn-modern-Cpp-techniques-in-ClickHouse/">Learn modern C++ techniques in ClickHouse</a>
        </li>
      
        <li>
          <a href="/2023/03/28/AST-based-Query-Fuzzer-in-ClickHouse/">AST-based Query Fuzzer in ClickHouse</a>
        </li>
      
        <li>
          <a href="/2022/09/21/How-Vectorization-Execution-Implemented-in-ClickHouse/">How Vectorization Execution Implemented in ClickHouse</a>
        </li>
      
        <li>
          <a href="/2020/12/25/How-to-Implement-User-defined-functions-in-ClickHouse/">How to Implement User-defined-functions in ClickHouse</a>
        </li>
      
        <li>
          <a href="/2020/06/07/Large-Scale-Graph-Analysis-Systems/">Large Scale Graph Analysis Systems</a>
        </li>
      
    </ul>
  </div>


  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2023/09/">September 2023</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2023/03/">March 2023</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2022/09/">September 2022</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/12/">December 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2020/06/">June 2020</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Categories</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/C/">C++</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/ClickHouse/">ClickHouse</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/Graph-Systems/">Graph Systems</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/categories/LLVM/">LLVM</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list" itemprop="keywords"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/C/" rel="tag">C++</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/ClickHouse/" rel="tag">ClickHouse</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Fuzzer/" rel="tag">Fuzzer</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Graph-Systems/" rel="tag">Graph Systems</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/LLVM/" rel="tag">LLVM</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Pipeline/" rel="tag">Pipeline</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Udf/" rel="tag">Udf</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Vectorization/" rel="tag">Vectorization</a><span class="sidebar-module-list-count">1</span></li></ul>
  </div>




        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2018  ~ 2023  flynn<br>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


</body>
</html>
